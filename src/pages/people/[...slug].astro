---
import type { CollectionEntry } from "astro:content";
import { getCollection, getEntry } from "astro:content";
import BaseHead from "@/components/BaseHead.astro";
import SiteShell from "@/layouts/SiteShell.astro";
import { getPeopleByExpertise, getPeopleByOrganization } from "@/data/people";
import { getAllResearch } from "@/data/research";
import { getAllHardware } from "@/data/hardware";
import { getAllSoftware } from "@/data/software";
import { PersonDetail } from "@/components/detail/views/PersonDetail";
import { isDraftVisible } from "@/utils/drafts";

export async function getStaticPaths() {
  const people = await getCollection("people", ({ data }) => {
    // In production, exclude drafts and private people. In development, show all.
    return isDraftVisible(data.draft);
  });
  return people.map((entry) => ({
    params: { slug: entry.id },
    props: { entry },
  }));
}

const { entry } = Astro.props;
const { data } = entry;
const fullName = data.honorific ? `${data.honorific} ${data.name}` : data.name;

// Get related people (by expertise or organization)
async function getRelatedPeople(
  person: CollectionEntry<"people">,
  limit: number = 3,
) {
  const relatedPeople: CollectionEntry<"people">[] = [];
  const seenIds = new Set<string>([person.id]);

  // Find people with similar expertise
  if (person.data.expertise && person.data.expertise.length > 0) {
    for (const expertise of person.data.expertise.slice(0, 2)) {
      const expertisePeople = await getPeopleByExpertise(expertise);
      for (const p of expertisePeople) {
        if (!seenIds.has(p.id) && relatedPeople.length < limit) {
          relatedPeople.push(p);
          seenIds.add(p.id);
        }
      }
    }
  }

  // If not enough, find people from same organization
  if (
    relatedPeople.length < limit &&
    person.data.affiliations &&
    person.data.affiliations.length > 0
  ) {
    const currentAffiliations = person.data.affiliations.filter(
      (aff) => !aff.endDate,
    );
    for (const aff of currentAffiliations) {
      const orgPeople = await getPeopleByOrganization(aff.organizationId);
      for (const p of orgPeople) {
        if (!seenIds.has(p.id) && relatedPeople.length < limit) {
          relatedPeople.push(p);
          seenIds.add(p.id);
        }
      }
    }
  }

  return relatedPeople.slice(0, limit);
}

const relatedPeople = await getRelatedPeople(entry, 3);

// Get related content by this person
async function getPersonRelatedContent(personId: string) {
  // Get research where this person is an author
  const allResearch = await getAllResearch();
  const research = allResearch.filter((study) =>
    study.data.contributors?.some(
      (contributor) => contributor.personId === personId,
    ),
  );

  // Get hardware where this person is a contributor
  const allHardware = await getAllHardware();
  const hardware = allHardware.filter((hw) =>
    hw.data.contributors?.some(
      (contributor) =>
        contributor.type === "person" && contributor.personId === personId,
    ),
  );

  // Get software where this person is a contributor
  const allSoftware = await getAllSoftware();
  const software = allSoftware.filter((sw) =>
    sw.data.contributors?.some(
      (contributor) =>
        contributor.type === "person" && contributor.personId === personId,
    ),
  );

  // Events are tracked at the Semio-community level; per-person associations
  // are not available in the simplified roles schema.
  const events: CollectionEntry<"events">[] = [];

  return { research, hardware, software, events };
}

const relatedContent = await getPersonRelatedContent(entry.id);

const meta = {
  title: `${fullName} - Researcher Profile`,
  description: data.bio || `Profile of ${fullName}`,
};
const ogImage = `/og/people/${entry.id}.png`;

// Prepare status badges
const badges = [];
if (data.pronouns) {
  badges.push({
    text: data.pronouns,
    color: "gray" as const,
    variant: "outline" as const,
  });
}

// Prepare action buttons
const actionButtons = [];
if (data.links?.website) {
  actionButtons.push({
    href: data.links?.website,
    text: "Personal Website",
    variant: "default" as const,
    target: "_blank",
    rel: "noopener noreferrer",
    icon: "solar:global-line-duotone",
  });
}
if (data.links?.github) {
  actionButtons.push({
    href: `https://github.com/${data.links.github}`,
    text: "GitHub",
    variant: "secondary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
    icon: "mdi:github",
  });
}
if (data.links?.email) {
  actionButtons.push({
    href: `mailto:${data.links.email}`,
    text: "Email",
    variant: "tertiary" as const,
    icon: "solar:letter-line-duotone",
  });
}
if (data.links?.linkedin) {
  actionButtons.push({
    href: `https://linkedin.com/in/${data.links.linkedin}`,
    text: "LinkedIn",
    variant: "tertiary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
    icon: "mdi:linkedin",
  });
}
if (data.links?.twitter) {
  actionButtons.push({
    href: `https://twitter.com/${data.links.twitter}`,
    text: "Twitter",
    variant: "tertiary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
    icon: "mdi:twitter",
  });
}
if (data.links?.mastodon) {
  actionButtons.push({
    href: `https://mastodon.com/${data.links.mastodon}`,
    text: "Mastodon",
    variant: "tertiary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
    icon: "mdi:mastodon",
  });
}
if (data.links?.scheduling) {
  actionButtons.push({
    href: data.links?.scheduling,
    text: "Schedule",
    variant: "default" as const,
    target: "_blank",
    rel: "noopener noreferrer",
    icon: "solar:calendar-mark-line-duotone",
  });
}

// Prepare affiliations for display in main content
const currentAffiliations = await Promise.all(
  (data.affiliations || [])
    .filter((aff) => !aff.endDate)
    .map(async (aff) => {
      const org = await getEntry("organizations", aff.organizationId);
      return {
        ...aff,
        organization: org,
      };
    }),
);

const pastAffiliations = await Promise.all(
  (data.affiliations || [])
    .filter((aff) => aff.endDate)
    .map(async (aff) => {
      const org = await getEntry("organizations", aff.organizationId);
      return {
        ...aff,
        organization: org,
      };
    }),
);

// Prepare academic profile items
const academicProfileItems = [];
if (data.links?.orcid) {
  academicProfileItems.push({
    label: "ORCID",
    value: data.links.orcid,
    link: `https://orcid.org/${data.links.orcid}`,
    external: true,
  });
}
if (data.links?.googleScholar) {
  academicProfileItems.push({
    label: "Google Scholar",
    value: "View Profile",
    link: `https://scholar.google.com/citations?user=${data.links.googleScholar}`,
    external: true,
  });
}

// Prepare social media items
const socialMediaItems = [];
if (data.links?.twitter) {
  socialMediaItems.push({
    label: "Twitter",
    value: `@${data.links.twitter}`,
    link: `https://twitter.com/${data.links.twitter}`,
    external: true,
  });
}
if (data.links?.bluesky) {
  socialMediaItems.push({
    label: "Bluesky",
    value: data.links.bluesky,
    link: `https://bsky.app/profile/${data.links.bluesky}`,
    external: true,
  });
}
if (data.links?.mastodon) {
  socialMediaItems.push({
    label: "Mastodon",
    value: data.links.mastodon,
    link: data.links.mastodon,
    external: true,
  });
}---

<html
  class="overflow-x-hidden grid scroll-pt-[72px] scroll-smooth font-sans text-text text-xl md:text-base antialiased"
  lang="en"
>
  <head>
    <BaseHead
      title={meta.title}
      description={meta.description}
      ogImage={ogImage}
    />
  </head>
  <body class="relative min-h-screen w-full bg-surface">
    <SiteShell noPaddingTop showBackground containerClassName="max-w-5xl">
      <PersonDetail
        data={data}
        fullName={fullName}
        badges={badges}
        links={data.links}
        bio={data.bio}
        expertise={data.expertise || []}
        currentAffiliations={currentAffiliations.map((aff) => ({
          organizationId: aff.organizationId,
          organizationName:
            aff.organization?.data?.shortName || aff.organization?.data?.name,
          organizationImages: aff.organization?.data?.images,
          organizationData: aff.organization?.data,
          role: aff.role,
          department: aff.department,
        }))}
        pastAffiliations={pastAffiliations.map((aff) => ({
          organizationId: aff.organizationId,
          organizationName:
            aff.organization?.data?.shortName || aff.organization?.data?.name,
          organizationImages: aff.organization?.data?.images,
          organizationData: aff.organization?.data,
          role: aff.role,
          department: aff.department,
        }))}
        relatedContent={{
          research: relatedContent.research,
          hardware: relatedContent.hardware,
          software: relatedContent.software,
          events: relatedContent.events,
        }}
        relatedPeople={relatedPeople}
      />
    </SiteShell>
  </body>
</html>
