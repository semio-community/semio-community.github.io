---
import { type CollectionEntry, getCollection, getEntry } from "astro:content";
import PageLayout from "@/layouts/Base.astro";
import BaseDetailLayout from "@/components/detail/BaseDetailLayout.astro";
import { DetailHero } from "@/components/detail/DetailHero";
import { RelatedItemsGrid } from "@/components/detail/RelatedItemsGrid";
import LinkSection from "@/components/detail/LinkSection";
import { getRelatedResearch as fetchRelatedResearch } from "@/data/research";
import { getPerson, getFormattedAuthors } from "@/data/people";
import PersonPopoverWrapper from "@/components/people/PersonPopoverWrapper.astro";
import OrganizationChip from "@/components/ui/OrganizationChip.astro";
import { Fragment } from "react";
import HardwareCard from "@/components/cards/HardwareCard.astro";
import SoftwareCard from "@/components/cards/SoftwareCard.astro";

export async function getStaticPaths() {
  const researchEntries = await getCollection("research", ({ data }) => {
    // In production, exclude drafts. In development, show all.
    return import.meta.env.PROD ? data.draft !== true : true;
  });
  return researchEntries.map((entry) => ({
    params: { slug: entry.id },
    props: { entry },
  }));
}

const { entry } = Astro.props;
const { data } = entry;

function getPublishYear(researchEntry: CollectionEntry<"research">) {
  const date = researchEntry.data.publishDate
    ? new Date(researchEntry.data.publishDate)
    : undefined;
  if (date && !Number.isNaN(date.getTime())) {
    return date.getFullYear();
  }
  const year = (researchEntry.data as { year?: number }).year;
  return typeof year === "number" ? year : undefined;
}

const relatedResearch = await fetchRelatedResearch(entry, 3);

const publishDate = data.publishDate ? new Date(data.publishDate) : undefined;
const displayYear = getPublishYear(entry);
const legacyVenue = (data as { venue?: string }).venue;
const legacyCitations = (data as { citations?: number }).citations;

const authors = data.contributors ?? [];
const authorsString = await getFormattedAuthors(authors);

const meta = {
  title: `${data.title} - Research Study`,
  description: data.description,
};

const badges: Array<{
  text: string;
  color: "blue" | "gray" | "accent";
  variant: "solid" | "outline";
}> = [];

const typeLabels = {
  study: "Study",
  paper: "Research Paper",
  thesis: "Thesis",
  report: "Technical Report",
  preprint: "Preprint",
  dataset: "Dataset",
  benchmark: "Benchmark",
};
badges.push({
  text: typeLabels[data.type] || data.type,
  color: "blue" as const,
  variant: "solid" as const,
});

if (displayYear) {
  badges.push({
    text: displayYear.toString(),
    color: "gray" as const,
    variant: "outline" as const,
  });
}

if (data.featured) {
  badges.push({
    text: "Featured",
    color: "accent" as const,
    variant: "solid" as const,
  });
}

const authorsWithData = await Promise.all(
  authors.map(async (contributor) => {
    const person = await getPerson(contributor.personId);
    return {
      ...contributor,
      person: person?.data,
    };
  }),
);

authorsWithData.sort((a, b) => a.order - b.order);

const validAuthors = authorsWithData.filter((a) => a.person);

const publicationItems: Array<{ label: string; value: string }> = [];

if (legacyVenue) {
  publicationItems.push({
    label: "Venue",
    value: legacyVenue,
  });
}

if (displayYear) {
  publicationItems.push({
    label: "Year",
    value: displayYear.toString(),
  });
}

if (publishDate) {
  publicationItems.push({
    label: "Published",
    value: publishDate.toLocaleDateString("en-US", {
      month: "long",
      day: "numeric",
      year: "numeric",
    }),
  });
} else {
  publicationItems.push({
    label: "Status",
    value: "Ongoing",
  });
}

if (legacyCitations && legacyCitations > 0) {
  publicationItems.push({
    label: "Citations",
    value: legacyCitations.toString(),
  });
}

type OrganizationRole = "lead" | "affiliated" | "funding" | "collaborator";

const organizationRoleLabels: Record<OrganizationRole, string> = {
  lead: "Lead Organization",
  affiliated: "Affiliated Organization",
  funding: "Funding Organization",
  collaborator: "Collaborating Organization",
};

const organizationLinks: Array<{
  role: OrganizationRole;
  note?: string;
  organization: CollectionEntry<"organizations">;
}> = [];

for (const orgLink of data.organizations ?? []) {
  const role = orgLink.role as OrganizationRole;
  if (!organizationRoleLabels[role]) continue;
  const organization = await getEntry("organizations", orgLink.organizationId);
  if (!organization) continue;
  organizationLinks.push({
    role,
    note: orgLink.note,
    organization,
  });
}

const organizationsByRole: Record<
  OrganizationRole,
  Array<{ organization: CollectionEntry<"organizations">; note?: string }>
> = {
  lead: [],
  affiliated: [],
  funding: [],
  collaborator: [],
};

for (const item of organizationLinks) {
  organizationsByRole[item.role].push({
    organization: item.organization,
    note: item.note,
  });
}

const organizationRoleEntries = (
  Object.entries(organizationsByRole) as Array<
    [
      OrganizationRole,
      Array<{ organization: CollectionEntry<"organizations">; note?: string }>,
    ]
  >
).filter(([, list]) => list.length > 0);

// Get related hardware
const relatedHardwareItems = data.relatedHardware
  ? await Promise.all(
      data.relatedHardware.map((id) => getEntry("hardware", id)),
    )
  : [];
const validRelatedHardware = relatedHardwareItems.filter(
  (item) => item !== undefined,
);

// Get related software
const relatedSoftwareItems = data.relatedSoftware
  ? await Promise.all(
      data.relatedSoftware.map((id) => getEntry("software", id)),
    )
  : [];
const validRelatedSoftware = relatedSoftwareItems.filter(
  (item) => item !== undefined,
);
---

<PageLayout meta={meta} noPaddingTop>
  <BaseDetailLayout>
    <Fragment slot="hero">
      <DetailHero
        client:load
        image={data.images?.hero}
        title={data.title}
        subtitle={authorsString}
        badges={badges}
        featured={data.featured}
        thumbnail={data.images?.logo}
        entityType="research"
      />
    </Fragment>

    {/* Summary */}
    <Fragment slot="description">
      <div class="abstract-section">
        <div
          class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6"
        >
          <h3
            class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider"
          >
            SUMMARY
          </h3>
          <p class="text-accent-base">{data.description}</p>
        </div>
      </div>

      {/* External Links */}
      {
        data.links && Object.keys(data.links).length > 0 && (
          <div class="mt-6">
            <LinkSection
              client:load
              links={data.links}
              size="md"
              className="gap-1"
            />
          </div>
        )
      }
    </Fragment>

    {/* Contributors Section */}
    <Fragment slot="contributors">
      {/* Authors Section */}
      {
        validAuthors.length > 0 && (
          <div class="authors-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                CONTRIBUTORS
              </h3>
              <div class="flex flex-wrap gap-2">
                {validAuthors.map((author) => (
                  <div class="flex items-center gap-1">
                    <PersonPopoverWrapper
                      personId={author.personId}
                      role={author.affiliationSnapshot}
                    />
                    {author.corresponding && (
                      <span
                        class="text-xs text-accent-one"
                        title="Corresponding Author"
                      >
                        ✉
                      </span>
                    )}
                    {author.equalContribution && (
                      <span
                        class="text-xs text-color-500"
                        title="Equal Contribution"
                      >
                        *
                      </span>
                    )}
                  </div>
                ))}
              </div>
            </div>
          </div>
        )
      }

      {/* Organizations Section */}
      {
        organizationRoleEntries.length > 0 && (
          <div class="organizations-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                ORGANIZATIONS
              </h3>
              {organizationRoleEntries.map(([role, organizations]) => (
                <div class="mb-4">
                  <h4 class="text-xs font-medium mb-2 text-color-600 dark:text-color-400">
                    {organizationRoleLabels[role]}
                  </h4>
                  <div class="flex flex-wrap gap-2">
                    {organizations.map(({ organization, note }) => (
                      <div class="flex items-center gap-2">
                        <OrganizationChip
                          partnerId={organization.id}
                          role={organizationRoleLabels[role]}
                        />
                        {note && (
                          <span class="text-xs text-color-500 dark:text-color-400 italic">
                            {note}
                          </span>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          </div>
        )
      }
    </Fragment>

    {/* Publication Details */}
    <Fragment slot="metadata">
      {
        publicationItems.length > 0 && (
          <div class="publication-details">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                DETAILS
              </h3>
              <div class="grid grid-cols-2 md:grid-cols-3 gap-4 text-sm">
                {publicationItems.map((item) => (
                  <div>
                    <span class="text-xs text-color-600 dark:text-color-400 font-semibold block mb-1">
                      {item.label}
                    </span>
                    <span class="text-accent-base">{item.value}</span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        )
      }
    </Fragment>

    {/* Topics */}
    <Fragment slot="tags">
      {
        data.topics && data.topics.length > 0 && (
          <div class="topics-section">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                RESEARCH TOPICS
              </h3>
              <div class="flex flex-wrap gap-2">
                {data.topics.map((topic) => (
                  <span class="px-3 py-1.5 bg-accent-one/10 rounded-lg text-sm text-accent-base">
                    {topic}
                  </span>
                ))}
              </div>
            </div>
          </div>
        )
      }
    </Fragment>

    {/* Main content from MDX file */}
    <!-- <Content /> -->

    {/* Related Items */}
    <Fragment slot="related">
      {/* Related Hardware */}
      {
        validRelatedHardware.length > 0 && (
          <div class="mb-12">
            <h3 class="text-lg font-semibold mb-4">Related Hardware</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {validRelatedHardware.map((hw) => (
                <HardwareCard hardwareId={hw.id} />
              ))}
            </div>
          </div>
        )
      }

      {/* Related Software */}
      {
        validRelatedSoftware.length > 0 && (
          <div class="mb-12">
            <h3 class="text-lg font-semibold mb-4">Related Software</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {validRelatedSoftware.map((sw) => (
                <SoftwareCard softwareId={sw.id} />
              ))}
            </div>
          </div>
        )
      }

      {/* Related Research */}
      {
        relatedResearch && relatedResearch.length > 0 && (
          <RelatedItemsGrid
            client:load
            title="Related Research"
            subtitle="Related papers, datasets, and benchmarks"
            items={
              relatedResearch.map((relatedEntry) => {
                const yearLabel = getPublishYear(relatedEntry);
                const typeLabel =
                  typeLabels[relatedEntry.data.type] || relatedEntry.data.type;
                return {
                  id: relatedEntry.id,
                  data: {
                    name: relatedEntry.data.title,
                    title: relatedEntry.data.title,
                    description: relatedEntry.data.description,
                    type: relatedEntry.data.type,
                    featured: relatedEntry.data.featured,
                    images: relatedEntry.data.images,
                    links: relatedEntry.data.links,
                    shortDescription: [typeLabel, yearLabel]
                      .filter(Boolean)
                      .join(" • "),
                  },
                };
              }) as any
            }
            itemType="research"
            columns={3}
          />
        )
      }
    </Fragment>
  </BaseDetailLayout>
</PageLayout>
