---
import {
  type CollectionEntry,
  getCollection,
  render,
  getEntry,
} from "astro:content";
import PageLayout from "@/layouts/Base.astro";
import BaseDetailLayout from "@/components/detail/BaseDetailLayout.astro";
import { DetailHero } from "@/components/detail/DetailHero";
import { ActionButtonGroup } from "@/components/detail/ActionButtonGroup";
import { MetadataCard } from "@/components/detail/MetadataCard";
import { ChipsCard } from "@/components/detail/ChipsCard";
import { TagsSection } from "@/components/detail/TagsSection";
import { RelatedItemsGrid } from "@/components/detail/RelatedItemsGrid";
import ContentSection from "@/components/detail/ContentSection.astro";
import { getAllStudies } from "@/data/studies";
import { getPerson, getFormattedAuthors } from "@/data/people";
import { getRelatedHardware } from "@/data/hardware";
import { getRelatedSoftware } from "@/data/software";
import PersonPopoverWrapper from "@/components/PersonPopoverWrapper.astro";
import OrganizationChip from "@/components/OrganizationChip.astro";
import BasicChip from "@/components/BasicChip.astro";
import { Fragment } from "react";
import { Icon } from "astro-icon/components";

export async function getStaticPaths() {
  const studies = await getCollection("studies", ({ data }) => {
    // In production, exclude drafts. In development, show all.
    return import.meta.env.PROD ? data.draft !== true : true;
  });
  return studies.map((entry) => ({
    params: { slug: entry.id },
    props: { entry },
  }));
}

type Props = {
  entry: CollectionEntry<"studies">;
};

const { entry } = Astro.props;
const { Content } = await render(entry);
const { data } = entry;

// Get related studies (by keywords or research areas)
async function getRelatedStudies(
  study: CollectionEntry<"studies">,
  limit: number = 3,
) {
  const allStudies = await getAllStudies();
  const relatedStudies: CollectionEntry<"studies">[] = [];

  // Filter out the current study
  const otherStudies = allStudies.filter((s) => s.id !== study.id);

  // Score each study based on similarity
  const scoredStudies = otherStudies.map((s) => {
    let score = 0;

    // Same type gets points
    if (s.data.type === study.data.type) score += 2;

    // Same venue gets points
    if (s.data.venue && s.data.venue === study.data.venue) score += 3;

    // Close year gets points (within 2 years)
    const yearDiff = Math.abs(s.data.year - study.data.year);
    if (yearDiff <= 2) score += 3 - yearDiff;

    // Overlapping keywords get points
    const studyKeywords = new Set(study.data.keywords || []);
    const otherKeywords = s.data.keywords || [];
    const keywordOverlap = otherKeywords.filter((kw) =>
      studyKeywords.has(kw),
    ).length;
    score += keywordOverlap * 2;

    // Overlapping research areas get points
    const studyAreas = new Set(study.data.researchArea || []);
    const otherAreas = s.data.researchArea || [];
    const areaOverlap = otherAreas.filter((area) =>
      studyAreas.has(area),
    ).length;
    score += areaOverlap * 2;

    // Shared authors get high points
    const studyAuthors = new Set(study.data.authors.map((a) => a.personId));
    const otherAuthors = s.data.authors.map((a) => a.personId);
    const authorOverlap = otherAuthors.filter((id) =>
      studyAuthors.has(id),
    ).length;
    score += authorOverlap * 5;

    return { study: s, score };
  });

  // Sort by score and take the top ones
  scoredStudies.sort((a, b) => b.score - a.score);

  return scoredStudies
    .filter((ss) => ss.score > 0)
    .slice(0, limit)
    .map((ss) => ss.study);
}

const relatedStudies = await getRelatedStudies(entry, 3);

// Get formatted authors string
const authorsString = await getFormattedAuthors(data.authors);

const meta = {
  title: `${data.title} - Research Study`,
  description: data.abstract,
};

// Prepare status badges
const badges = [];

// Type badge
const typeLabels = {
  paper: "Research Paper",
  thesis: "Thesis",
  report: "Technical Report",
  preprint: "Preprint",
  dataset: "Dataset",
  benchmark: "Benchmark",
};
badges.push({
  text: typeLabels[data.type] || data.type,
  color: "blue" as const,
  variant: "solid" as const,
});

// Year badge
badges.push({
  text: data.year.toString(),
  color: "gray" as const,
  variant: "outline" as const,
});

if (data.featured) {
  badges.push({
    text: "Featured",
    color: "accent" as const,
    variant: "solid" as const,
  });
}

// Prepare action buttons
const actionButtons = [];
if (data.links?.pdf) {
  actionButtons.push({
    href: data.links.pdf,
    text: "View PDF",
    variant: "primary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
  });
}
if (data.links?.doi) {
  actionButtons.push({
    href: `https://doi.org/${data.links.doi}`,
    text: "DOI",
    variant: "default" as const,
    target: "_blank",
    rel: "noopener noreferrer",
  });
}
if (data.links?.arxiv) {
  actionButtons.push({
    href: data.links.arxiv,
    text: "arXiv",
    variant: "secondary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
  });
}
if (data.links?.code) {
  actionButtons.push({
    href: data.links.code,
    text: "Code",
    variant: "tertiary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
  });
}
if (data.links?.data) {
  actionButtons.push({
    href: data.links.data,
    text: "Dataset",
    variant: "tertiary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
  });
}
if (data.links?.video) {
  actionButtons.push({
    href: data.links.video,
    text: "Video",
    variant: "tertiary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
  });
}
if (data.links?.website) {
  actionButtons.push({
    href: data.links.website,
    text: "Project Website",
    variant: "tertiary" as const,
    target: "_blank",
    rel: "noopener noreferrer",
  });
}

// Get author details with PersonPopover
const authorsWithData = await Promise.all(
  data.authors.map(async (author) => {
    const person = await getPerson(author.personId);
    return {
      ...author,
      person: person?.data,
    };
  }),
);

// Sort by order
authorsWithData.sort((a, b) => a.order - b.order);

// Filter out authors where person data couldn't be found
const validAuthors = authorsWithData.filter((a) => a.person);

// Prepare publication details
const publicationItems = [];
if (data.venue) {
  publicationItems.push({
    label: "Venue",
    value: data.venue,
  });
}
publicationItems.push({
  label: "Year",
  value: data.year.toString(),
});
if (data.citations && data.citations > 0) {
  publicationItems.push({
    label: "Citations",
    value: data.citations.toString(),
  });
}
if (data.publishDate) {
  const pubDate = new Date(data.publishDate);
  publicationItems.push({
    label: "Published",
    value: pubDate.toLocaleDateString("en-US", {
      month: "long",
      day: "numeric",
      year: "numeric",
    }),
  });
}

// Get affiliated organizations
const affiliatedOrgs = await Promise.all(
  (data.affiliatedOrganizations || []).map((id) => getEntry("partners", id)),
);
const validAffiliatedOrgs = affiliatedOrgs.filter((org) => org !== undefined);

// Get funding organizations
const fundingOrgs = await Promise.all(
  (data.fundingOrganizations || []).map((id) => getEntry("partners", id)),
);
const validFundingOrgs = fundingOrgs.filter((org) => org !== undefined);

// Get related hardware
const relatedHardwareItems = data.relatedHardware
  ? await Promise.all(
      data.relatedHardware.map((id) => getEntry("hardware", id)),
    )
  : [];
const validRelatedHardware = relatedHardwareItems.filter(
  (item) => item !== undefined,
);

// Get related software
const relatedSoftwareItems = data.relatedSoftware
  ? await Promise.all(
      data.relatedSoftware.map((id) => getEntry("software", id)),
    )
  : [];
const validRelatedSoftware = relatedSoftwareItems.filter(
  (item) => item !== undefined,
);

// Prepare related resources metadata
const relatedResourcesItems: any[] = [];
validRelatedHardware.forEach((hw) => {
  if (hw) {
    relatedResourcesItems.push({
      label: "Hardware",
      value: hw.data.name,
      link: `/hardware/${hw.id}`,
    });
  }
});
validRelatedSoftware.forEach((sw) => {
  if (sw) {
    relatedResourcesItems.push({
      label: "Software",
      value: sw.data.name,
      link: `/software/${sw.id}`,
    });
  }
});
---

<PageLayout meta={meta} noPaddingTop>
  <BaseDetailLayout showSidebar={false}>
    <Fragment slot="hero">
      <DetailHero
        client:load
        image={data.images?.hero}
        title={data.title}
        subtitle={authorsString}
        badges={badges}
        featured={data.featured}
        thumbnail={data.images?.logo}
        entityType="study"
      />
    </Fragment>

    <Fragment slot="actions">
      {/* Abstract Section */}
      <div class="abstract-section mb-8">
        <div
          class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6"
        >
          <h3
            class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider"
          >
            ABSTRACT
          </h3>
          <p class="text-accent-base">{data.abstract}</p>
        </div>
      </div>

      <div class="abstract-section mb-8">
        {
          actionButtons.length > 0 && (
            <ActionButtonGroup client:load buttons={actionButtons} />
          )
        }
      </div>

      {/* Authors Section */}
      {
        validAuthors.length > 0 && (
          <div class="authors-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                AUTHORS
              </h3>
              <div class="flex flex-wrap gap-2">
                {validAuthors.map((author) => (
                  <div class="flex items-center gap-1">
                    <PersonPopoverWrapper
                      personId={author.personId}
                      role={author.affiliationSnapshot}
                    />
                    {author.corresponding && (
                      <span
                        class="text-xs text-accent-one"
                        title="Corresponding Author"
                      >
                        ✉
                      </span>
                    )}
                    {author.equalContribution && (
                      <span
                        class="text-xs text-color-500"
                        title="Equal Contribution"
                      >
                        *
                      </span>
                    )}
                  </div>
                ))}
              </div>
            </div>
          </div>
        )
      }

      {/* Organizations Section */}
      {
        (validAffiliatedOrgs.length > 0 || validFundingOrgs.length > 0) && (
          <div class="organizations-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                ORGANIZATIONS
              </h3>
              {validAffiliatedOrgs.length > 0 && (
                <div class="mb-4">
                  <h4 class="text-xs font-medium mb-2 text-color-600 dark:text-color-400">
                    Affiliated Institutions
                  </h4>
                  <div class="flex flex-wrap gap-2">
                    {validAffiliatedOrgs.map(
                      (org) =>
                        org && (
                          <OrganizationChip
                            partnerId={org.id}
                            role="Affiliated Institution"
                          />
                        ),
                    )}
                  </div>
                </div>
              )}
              {validFundingOrgs.length > 0 && (
                <div>
                  <h4 class="text-xs font-medium mb-2 text-color-600 dark:text-color-400">
                    Funding Organizations
                  </h4>
                  <div class="flex flex-wrap gap-2">
                    {validFundingOrgs.map(
                      (org) =>
                        org && (
                          <OrganizationChip
                            partnerId={org.id}
                            role="Funding Partner"
                          />
                        ),
                    )}
                  </div>
                </div>
              )}
            </div>
          </div>
        )
      }

      {/* Publication Details */}
      {
        publicationItems.length > 0 && (
          <div class="publication-details mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                PUBLICATION DETAILS
              </h3>
              <div class="grid grid-cols-2 md:grid-cols-3 gap-4 text-sm">
                {publicationItems.map((item) => (
                  <div>
                    <span class="text-xs text-color-600 dark:text-color-400 font-semibold block mb-1">
                      {item.label}
                    </span>
                    <span class="text-accent-base">{item.value}</span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        )
      }

      {/* Keywords and Research Areas */}
      {
        (data.keywords?.length > 0 || data.researchArea?.length > 0) && (
          <div class="topics-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                RESEARCH TOPICS
              </h3>

              {data.keywords && data.keywords.length > 0 && (
                <div class="mb-4">
                  <h4 class="text-xs font-medium mb-2 text-color-600 dark:text-color-400">
                    Keywords
                  </h4>
                  <div class="flex flex-wrap gap-2">
                    {data.keywords.map((keyword) => (
                      <span class="px-3 py-1.5 bg-accent-one/10 rounded-lg text-sm text-accent-base">
                        {keyword}
                      </span>
                    ))}
                  </div>
                </div>
              )}

              {data.researchArea && data.researchArea.length > 0 && (
                <div>
                  <h4 class="text-xs font-medium mb-2 text-color-600 dark:text-color-400">
                    Research Areas
                  </h4>
                  <div class="flex flex-wrap gap-2">
                    {data.researchArea.map((area) => (
                      <span class="px-3 py-1.5 bg-accent-two/10 rounded-lg text-sm text-accent-base">
                        {area}
                      </span>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>
        )
      }

      {/* Related Resources */}
      {
        relatedResourcesItems.length > 0 && (
          <div class="related-resources mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                RELATED RESOURCES
              </h3>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                {relatedResourcesItems.map((item) => (
                  <a
                    href={item.link}
                    class="flex items-center justify-between p-3 bg-accent-one/5 rounded-lg hover:bg-accent-one/10 transition-colors group"
                  >
                    <div class="flex items-center gap-3">
                      <span class="text-xs text-color-600 dark:text-color-400 font-semibold">
                        {item.label}
                      </span>
                      <span class="text-sm text-accent-base group-hover:text-accent-two transition-colors">
                        {item.value}
                      </span>
                    </div>
                    <Icon
                      name="solar:arrow-right-line-duotone"
                      class="w-4 h-4 text-accent-one opacity-50 group-hover:opacity-100 transition-opacity"
                    />
                  </a>
                ))}
              </div>
            </div>
          </div>
        )
      }
    </Fragment>

    <!-- Main content from MDX file -->
    <!-- <Content /> -->

    <Fragment slot="related">
      {
        relatedStudies && relatedStudies.length > 0 && (
          <RelatedItemsGrid
            client:load
            title="Related Studies"
            subtitle="Similar research papers and reports"
            items={
              relatedStudies.map((study) => ({
                id: study.id,
                data: {
                  name: study.data.title,
                  title: study.data.title,
                  displayName: undefined,
                  description: study.data.abstract,
                  abstract: study.data.abstract,
                  status: undefined,
                  type: study.data.type,
                  category: undefined,
                  featured: study.data.featured,
                  images: study.data.images,
                  avatar: undefined,
                  logo: undefined,
                  thumbnail: undefined,
                  banner: undefined,
                  links: study.data.links,
                  shortDescription: `${typeLabels[study.data.type] || study.data.type} • ${study.data.year}`,
                },
              })) as any
            }
            itemType="studies"
            columns={3}
          />
        )
      }
    </Fragment>
  </BaseDetailLayout>
</PageLayout>
