---
import { type CollectionEntry, getCollection } from "astro:content";
import PageLayout from "@/layouts/Base.astro";
import BaseDetailLayout from "@/components/detail/BaseDetailLayout.astro";
import { DetailHero } from "@/components/detail/DetailHero";
import { RelatedItemsGrid } from "@/components/detail/RelatedItemsGrid";
import InfoCard from "@/components/detail/InfoCard.astro";
import LinkButton from "@/components/detail/LinkButton.astro";
import ContentSection from "@/components/detail/ContentSection.astro";
import { getAllEvents } from "@/data/events";
import SpecificationsList from "@/components/detail/SpecificationsList.astro";
import BasicChip from "@/components/ui/BasicChip.astro";
import { Fragment } from "react";
import { createLinkButton } from "@/config/linkConfig";
import { getEventPreviewDescriptionText } from "@/utils/events";

export async function getStaticPaths() {
  const events = await getCollection("events", ({ data }) => {
    // In production, exclude drafts. In development, show all.
    return import.meta.env.PROD ? data.draft !== true : true;
  });
  return events.map((entry) => ({
    params: { slug: entry.id },
    props: { entry },
  }));
}

const { entry } = Astro.props;
const { data } = entry;

// Get related events (by type or topics)
async function getRelatedEvents(
  event: CollectionEntry<"events">,
  limit: number = 3,
) {
  const allEvents = await getAllEvents();

  // Filter out the current event and past events (unless current is also past)
  const currentDate = new Date();
  const isCurrentPast = new Date(event.data.endDate) < currentDate;

  const otherEvents = allEvents.filter((e) => {
    if (e.id === event.id) return false;
    // If current event is past, include all; otherwise prefer upcoming
    if (!isCurrentPast) {
      const eventDate = new Date(e.data.startDate);
      if (eventDate < currentDate) return false;
    }
    return true;
  });

  // Score each event based on similarity
  const scoredEvents = otherEvents.map((e) => {
    let score = 0;

    // Same type gets points
    if (e.data.type === event.data.type) score += 3;

    // Same delivery mode (online vs in-person) gets points
    if (
      Boolean(e.data.location.online) === Boolean(event.data.location.online)
    ) {
      score += 2;
    }

    // Same city gets points
    if (e.data.location.city === event.data.location.city) score += 2;

    // Same country gets points
    if (e.data.location.country === event.data.location.country) score += 1;

    // Overlapping topics get points
    const eventTopics = new Set(event.data.topics || []);
    const otherTopics = e.data.topics || [];
    const topicOverlap = otherTopics.filter((topic) =>
      eventTopics.has(topic),
    ).length;
    score += topicOverlap * 2;

    // Temporal proximity (within 3 months) gets points
    const timeDiff = Math.abs(
      new Date(e.data.startDate).getTime() -
        new Date(event.data.startDate).getTime(),
    );
    const monthsDiff = timeDiff / (1000 * 60 * 60 * 24 * 30);
    if (monthsDiff <= 3) score += 3 - Math.floor(monthsDiff);

    return { event: e, score };
  });

  // Sort by score and take the top ones
  scoredEvents.sort((a, b) => b.score - a.score);

  return scoredEvents
    .filter((se) => se.score > 0)
    .slice(0, limit)
    .map((se) => se.event);
}

const relatedEvents = await getRelatedEvents(entry, 3);

const meta = {
  title: `${data.name} - Event`,
  description: data.description,
};

// Determine event status
const currentDate = new Date();
const startDate = new Date(data.startDate);
const endDate = new Date(data.endDate);
let eventStatus = "upcoming";
if (currentDate > endDate) {
  eventStatus = "past";
} else if (currentDate >= startDate && currentDate <= endDate) {
  eventStatus = "ongoing";
}

// Prepare status badges
const badges = [];

// Status badge
if (eventStatus === "ongoing") {
  badges.push({
    text: "Ongoing",
    color: "green" as const,
    variant: "solid" as const,
  });
} else if (eventStatus === "upcoming") {
  badges.push({
    text: "Upcoming",
    color: "blue" as const,
    variant: "solid" as const,
  });
} else {
  badges.push({
    text: "Past Event",
    color: "gray" as const,
    variant: "outline" as const,
  });
}

if (typeof data.location.online === "boolean") {
  badges.push({
    text: data.location.online ? "Online" : "In Person",
    color: data.location.online ? ("accent" as const) : ("green" as const),
    variant: "outline" as const,
  });
}

const typeLabels = {
  conference: "Conference",
  workshop: "Workshop",
  hackathon: "Hackathon",
  meetup: "Meetup",
  webinar: "Webinar",
  competition: "Competition",
};
badges.push({
  text: typeLabels[data.type] || data.type,
  color: "blue" as const,
  variant: "outline" as const,
});

// Prepare link buttons using centralized configuration
const linkButtons = [];
if (data.links?.registration && eventStatus !== "past") {
  linkButtons.push(
    createLinkButton("registration", data.links.registration, "Register Now", {
      variant: "primary",
    }),
  );
}
if (data.links?.website) {
  linkButtons.push(
    createLinkButton("website", data.links.website, "Event Website"),
  );
}
if (data.links?.program) {
  linkButtons.push(
    createLinkButton("documentation", data.links.program, "Program", {
      variant: "secondary",
      icon: "solar:document-text-line-duotone",
    }),
  );
}
if (data.links?.proceedings && eventStatus === "past") {
  linkButtons.push(
    createLinkButton("documentation", data.links.proceedings, "Proceedings", {
      variant: "tertiary",
      icon: "solar:book-line-duotone",
    }),
  );
}
if (data.links?.recordings && eventStatus === "past") {
  linkButtons.push(
    createLinkButton("video", data.links.recordings, "Recordings", {
      variant: "tertiary",
    }),
  );
}

// Format dates for display
const formatDate = (date: Date) => {
  return date.toLocaleDateString("en-US", {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric",
  });
};

// Prepare event details
const eventDetailsItems = [];
eventDetailsItems.push({
  label: "Start Date",
  value: formatDate(startDate),
  icon: "solar:calendar-date-line-duotone",
});
eventDetailsItems.push({
  label: "End Date",
  value: formatDate(endDate),
  icon: "solar:calendar-mark-line-duotone",
});
// Prepare location details
const locationItems = [];
if (data.location.venue) {
  locationItems.push({
    label: "Venue",
    value: data.location.venue,
    icon: "solar:buildings-line-duotone",
  });
}
locationItems.push({
  label: "Location",
  value: `${data.location.city}, ${data.location.country}`,
  icon: "solar:map-point-line-duotone",
});
if (data.location.online) {
  locationItems.push({
    label: "Online Access",
    value: "Available",
    icon: "solar:laptop-minimalistic-line-duotone",
  });
}
if (data.location.coordinates) {
  locationItems.push({
    label: "Map",
    value: "View on Google Maps",
    link: `https://maps.google.com/?q=${data.location.coordinates.lat},${data.location.coordinates.lng}`,
    external: true,
    icon: "solar:map-line-duotone",
  });
}

const formatRoleLabel = (role: string) =>
  role
    .split("-")
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join(" ");

const roleEntries = (data.roles || []).map((role) => ({
  value: role,
  label: formatRoleLabel(role),
}));

const descriptionText = getEventPreviewDescriptionText(data)
---

<PageLayout meta={meta} noPaddingTop>
  <BaseDetailLayout>
    <Fragment slot="hero">
      <DetailHero
        client:load
        image={data.images?.hero}
        title={data.name}
        subtitle={descriptionText}
        badges={badges}
        featured={data.featured}
        logo={data.images?.logo}
        entityType="event"
      />
    </Fragment>

    {/* External Links */}
    <Fragment slot="links">
      {
        linkButtons.length > 0 && (
          <InfoCard title="LINKS & RESOURCES">
            <div class="flex flex-wrap gap-3">
              {linkButtons.map((button) => (
                <LinkButton
                  href={button.href}
                  text={button.text}
                  icon={button.icon}
                  external={button.external}
                  variant={button.variant || "default"}
                />
              ))}
            </div>
          </InfoCard>
        )
      }
    </Fragment>

    {/* Description */}
    <Fragment slot="description">
      <ContentSection title="ABOUT THE EVENT" content={data.description} />
    </Fragment>

    {/* Event Metadata (Details & Location) */}
    <Fragment slot="metadata">
      {/* Event Details */}
      <SpecificationsList
        title="EVENT DETAILS"
        items={eventDetailsItems}
        defaultItemIcon="solar:calendar-line-duotone"
      />

      {/* Location */}
      <SpecificationsList
        title="LOCATION"
        items={locationItems}
        defaultItemIcon="solar:map-point-line-duotone"
      />
    </Fragment>

    {/* Semio Community Roles */}
    <Fragment slot="contributors">
      {
        roleEntries.length > 0 && (
          <div class="roles-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                SEMIO COMMUNITY ROLES
              </h3>
              <div class="flex flex-wrap gap-2">
                {roleEntries.map((role) => (
                  <BasicChip
                    text={role.label}
                    variant="primary"
                  />
                ))}
              </div>
            </div>
          </div>
        )
      }
    </Fragment>

    {/* Topics */}
    {
      data.topics && data.topics.length > 0 && (
        <Fragment slot="tags">
          <div class="topics-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                TOPICS
              </h3>
              <div class="flex flex-wrap gap-2">
                {data.topics.map((topic: string) => (
                  <span class="px-3 py-1.5 bg-accent-two/10 rounded-lg text-sm text-accent-base">
                    {topic}
                  </span>
                ))}
              </div>
            </div>
          </div>
        </Fragment>
      )
    }

    {/* Main content from MDX file */}
    <!-- <Content /> -->

    {/* Related Events */}
    <Fragment slot="related">
      {
        relatedEvents && relatedEvents.length > 0 && (
          <RelatedItemsGrid
            client:load
            title="Related Events"
            subtitle="Similar upcoming and past events"
            items={
              relatedEvents.map((event) => ({
                id: event.id,
                data: {
                  name: event.data.name,
                  title: undefined,
                  displayName: event.data.displayName,
                  description: event.data.description,
                  abstract: undefined,
                  status: undefined,
                  type: event.data.type,
                  category: undefined,
                  featured: event.data.featured,
                  images: event.data.images,
                  avatar: undefined,
                  logo: undefined,
                  thumbnail: undefined,
                  banner: event.data.images?.hero,
                  links: event.data.links,
                  startDate: event.data.startDate,
                  endDate: event.data.endDate,
                  shortDescription: `${
                    typeLabels[event.data.type] || event.data.type
                  } • ${event.data.location.city}`,
                },
              })) as any
            }
            itemType="events"
            columns={3}
          />
        )
      }
    </Fragment>
  </BaseDetailLayout>
</PageLayout>
