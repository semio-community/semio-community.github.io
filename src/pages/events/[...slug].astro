---
import {
  type CollectionEntry,
  getCollection,
  render,
  getEntry,
} from "astro:content";
import PageLayout from "@/layouts/Base.astro";
import BaseDetailLayout from "@/components/detail/BaseDetailLayout.astro";
import { DetailHero } from "@/components/detail/DetailHero";
import { RelatedItemsGrid } from "@/components/detail/RelatedItemsGrid";
import InfoCard from "@/components/detail/InfoCard.astro";
import LinkButton from "@/components/detail/LinkButton.astro";
import ContentSection from "@/components/detail/ContentSection.astro";
import SpecificationsList from "@/components/detail/SpecificationsList.astro";
import { getAllEvents } from "@/data/events";
import { getPerson } from "@/data/people";
import PersonPopoverWrapper from "@/components/PersonPopoverWrapper.astro";
import OrganizationChip from "@/components/OrganizationChip.astro";
import BasicChip from "@/components/BasicChip.astro";
import { Fragment } from "react";
import { Icon } from "astro-icon/components";
import { createLinkButton } from "@/config/linkConfig";
import { getEventPreviewDescriptionText } from "@/utils/events";

export async function getStaticPaths() {
  const events = await getCollection("events", ({ data }) => {
    // In production, exclude drafts. In development, show all.
    return import.meta.env.PROD ? data.draft !== true : true;
  });
  return events.map((entry) => ({
    params: { slug: entry.id },
    props: { entry },
  }));
}

const { entry } = Astro.props;
const { data } = entry;

// Get related events (by type, format, or topics)
async function getRelatedEvents(
  event: CollectionEntry<"events">,
  limit: number = 3,
) {
  const allEvents = await getAllEvents();

  // Filter out the current event and past events (unless current is also past)
  const currentDate = new Date();
  const isCurrentPast = new Date(event.data.endDate) < currentDate;

  const otherEvents = allEvents.filter((e) => {
    if (e.id === event.id) return false;
    // If current event is past, include all; otherwise prefer upcoming
    if (!isCurrentPast) {
      const eventDate = new Date(e.data.startDate);
      if (eventDate < currentDate) return false;
    }
    return true;
  });

  // Score each event based on similarity
  const scoredEvents = otherEvents.map((e) => {
    let score = 0;

    // Same type gets points
    if (e.data.type === event.data.type) score += 3;

    // Same format gets points
    if (e.data.format === event.data.format) score += 2;

    // Same city gets points
    if (e.data.location.city === event.data.location.city) score += 2;

    // Same country gets points
    if (e.data.location.country === event.data.location.country) score += 1;

    // Overlapping topics get points
    const eventTopics = new Set(event.data.topics || []);
    const otherTopics = e.data.topics || [];
    const topicOverlap = otherTopics.filter((topic) =>
      eventTopics.has(topic),
    ).length;
    score += topicOverlap * 2;

    // Overlapping tracks get points
    const eventTracks = new Set(event.data.tracks || []);
    const otherTracks = e.data.tracks || [];
    const trackOverlap = otherTracks.filter((track) =>
      eventTracks.has(track),
    ).length;
    score += trackOverlap;

    // Temporal proximity (within 3 months) gets points
    const timeDiff = Math.abs(
      new Date(e.data.startDate).getTime() -
        new Date(event.data.startDate).getTime(),
    );
    const monthsDiff = timeDiff / (1000 * 60 * 60 * 24 * 30);
    if (monthsDiff <= 3) score += 3 - Math.floor(monthsDiff);

    return { event: e, score };
  });

  // Sort by score and take the top ones
  scoredEvents.sort((a, b) => b.score - a.score);

  return scoredEvents
    .filter((se) => se.score > 0)
    .slice(0, limit)
    .map((se) => se.event);
}

const relatedEvents = await getRelatedEvents(entry, 3);

const meta = {
  title: `${data.name} - Event`,
  description: data.description,
};

// Determine event status
const currentDate = new Date();
const startDate = new Date(data.startDate);
const endDate = new Date(data.endDate);
const registrationDeadline = data.registrationDeadline
  ? new Date(data.registrationDeadline)
  : null;

let eventStatus = "upcoming";
if (currentDate > endDate) {
  eventStatus = "past";
} else if (currentDate >= startDate && currentDate <= endDate) {
  eventStatus = "ongoing";
}

// Prepare status badges
const badges = [];

// Status badge
if (eventStatus === "ongoing") {
  badges.push({
    text: "Ongoing",
    color: "green" as const,
    variant: "solid" as const,
  });
} else if (eventStatus === "upcoming") {
  badges.push({
    text: "Upcoming",
    color: "blue" as const,
    variant: "solid" as const,
  });
} else {
  badges.push({
    text: "Past Event",
    color: "gray" as const,
    variant: "outline" as const,
  });
}

// Format badge
const formatLabels = {
  "in-person": "In-Person",
  virtual: "Virtual",
  hybrid: "Hybrid",
};

// Type badge
const typeLabels = {
  conference: "Conference",
  workshop: "Workshop",
  hackathon: "Hackathon",
  meetup: "Meetup",
  webinar: "Webinar",
  competition: "Competition",
};
badges.push({
  text: typeLabels[data.type] || data.type,
  color: "blue" as const,
  variant: "outline" as const,
});

// Prepare link buttons using centralized configuration
const linkButtons = [];
if (
  data.links?.registration &&
  eventStatus !== "past" &&
  (!registrationDeadline || currentDate < registrationDeadline)
) {
  linkButtons.push(
    createLinkButton("registration", data.links.registration, "Register Now", {
      variant: "primary",
    }),
  );
}
if (data.links?.website) {
  linkButtons.push(
    createLinkButton("website", data.links.website, "Event Website"),
  );
}
if (data.links?.program) {
  linkButtons.push(
    createLinkButton("documentation", data.links.program, "Program", {
      variant: "secondary",
      icon: "solar:document-text-line-duotone",
    }),
  );
}
if (data.links?.proceedings && eventStatus === "past") {
  linkButtons.push(
    createLinkButton("documentation", data.links.proceedings, "Proceedings", {
      variant: "tertiary",
      icon: "solar:book-line-duotone",
    }),
  );
}
if (data.links?.recordings && eventStatus === "past") {
  linkButtons.push(
    createLinkButton("video", data.links.recordings, "Recordings", {
      variant: "tertiary",
    }),
  );
}

// Format dates for display
const formatDate = (date: Date) => {
  return date.toLocaleDateString("en-US", {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric",
  });
};

// Prepare event details
const eventDetailsItems = [];
eventDetailsItems.push({
  label: "Start Date",
  value: formatDate(startDate),
  icon: "solar:calendar-date-line-duotone",
});
eventDetailsItems.push({
  label: "End Date",
  value: formatDate(endDate),
  icon: "solar:calendar-mark-line-duotone",
});
if (registrationDeadline) {
  eventDetailsItems.push({
    label: "Registration Deadline",
    value: formatDate(registrationDeadline),
    icon: "solar:calendar-add-line-duotone",
  });
}
if (data.capacity) {
  eventDetailsItems.push({
    label: "Capacity",
    value: `${data.capacity} attendees`,
    icon: "solar:users-group-two-rounded-line-duotone",
  });
}

// Prepare location details
const locationItems = [];
if (data.location.venue) {
  locationItems.push({
    label: "Venue",
    value: data.location.venue,
    icon: "solar:buildings-line-duotone",
  });
}
locationItems.push({
  label: "Location",
  value: `${data.location.city}, ${data.location.country}`,
  icon: "solar:map-point-line-duotone",
});
if (data.location.online) {
  locationItems.push({
    label: "Online Access",
    value: "Available",
    icon: "solar:laptop-minimalistic-line-duotone",
  });
}
if (data.location.coordinates) {
  locationItems.push({
    label: "Map",
    value: "View on Google Maps",
    link: `https://maps.google.com/?q=${data.location.coordinates.lat},${data.location.coordinates.lng}`,
    external: true,
    icon: "solar:map-line-duotone",
  });
}

// Get organizers with data
const organizersWithData = await Promise.all(
  data.organizers.map(async (org) => {
    if (org.type === "person") {
      const person = await getPerson(org.id);
      return {
        ...org,
        data: person?.data,
      };
    } else {
      const organization = await getEntry("partners", org.id);
      return {
        ...org,
        data: organization?.data,
      };
    }
  }),
);

// Filter out invalid organizers
const validOrganizers = organizersWithData.filter((o) => o.data);

// Get speakers with data
const speakersWithData = await Promise.all(
  (data.speakers || []).map(async (speaker) => {
    const person = await getPerson(speaker.personId);
    return {
      ...speaker,
      person: person?.data,
    };
  }),
);

// Filter out invalid speakers
const validSpeakers = speakersWithData.filter((s) => s.person);

// Get sponsors with data
const sponsorsWithData = await Promise.all(
  (data.sponsors || []).map(async (sponsor) => {
    const organization = await getEntry("partners", sponsor.partnerId);
    return {
      ...sponsor,
      organization: organization?.data,
    };
  }),
);

// Filter out invalid sponsors
const validSponsors = sponsorsWithData.filter((s) => s.organization);

// Group sponsors by level
const sponsorsByLevel = {
  platinum: validSponsors.filter((s) => s.level === "platinum"),
  gold: validSponsors.filter((s) => s.level === "gold"),
  silver: validSponsors.filter((s) => s.level === "silver"),
  bronze: validSponsors.filter((s) => s.level === "bronze"),
  supporter: validSponsors.filter((s) => !s.level || s.level === "supporter"),
};

const descriptionText = getEventPreviewDescriptionText(data)
---

<PageLayout meta={meta} noPaddingTop>
  <BaseDetailLayout>
    <Fragment slot="hero">
      <DetailHero
        client:load
        image={data.images?.hero}
        title={data.name}
        subtitle={descriptionText}
        badges={badges}
        featured={data.featured}
        logo={data.images?.logo}
        entityType="event"
      />
    </Fragment>

    {/* External Links */}
    <Fragment slot="links">
      {
        linkButtons.length > 0 && (
          <InfoCard title="LINKS & RESOURCES">
            <div class="flex flex-wrap gap-3">
              {linkButtons.map((button) => (
                <LinkButton
                  href={button.href}
                  text={button.text}
                  icon={button.icon}
                  external={button.external}
                  variant={button.variant || "default"}
                />
              ))}
            </div>
          </InfoCard>
        )
      }
    </Fragment>

    {/* Description */}
    <Fragment slot="description">
      <ContentSection title="ABOUT THE EVENT" content={data.description} />
    </Fragment>

    {/* Event Metadata (Details & Location) */}
    <Fragment slot="metadata">
      {/* Event Details */}
      <SpecificationsList
        title="EVENT DETAILS"
        items={eventDetailsItems}
        defaultItemIcon="solar:calendar-line-duotone"
      />

      {/* Location */}
      <SpecificationsList
        title="LOCATION"
        items={locationItems}
        defaultItemIcon="solar:map-point-line-duotone"
      />
    </Fragment>

    {/* Contributors (Organizers, Speakers, Sponsors) */}
    <Fragment slot="contributors">
      {/* Organizers Section */}
      {
        validOrganizers.length > 0 && (
          <div class="organizers-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                ORGANIZERS
              </h3>
              <div class="flex flex-wrap gap-2">
                {validOrganizers.map((organizer) =>
                  organizer.type === "person" ? (
                    <PersonPopoverWrapper
                      personId={organizer.id}
                      role={organizer.role || "Organizer"}
                    />
                  ) : (
                    <OrganizationChip
                      partnerId={organizer.id}
                      role={organizer.role || "Organizing Institution"}
                    />
                  ),
                )}
              </div>
            </div>
          </div>
        )
      }

      {/* Speakers Section */}
      {
        validSpeakers.length > 0 && (
          <div class="speakers-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                SPEAKERS
              </h3>
              <div class="grid gap-3">
                {validSpeakers.map((speaker) => (
                  <div class="flex items-center justify-between">
                    <div class="flex items-center gap-2">
                      <PersonPopoverWrapper
                        personId={speaker.personId}
                        role={speaker.title}
                      />
                      {speaker.sessionType && (
                        <BasicChip
                          text={
                            speaker.sessionType === "keynote"
                              ? "Keynote"
                              : speaker.sessionType
                          }
                          variant={
                            speaker.sessionType === "keynote"
                              ? "primary"
                              : "default"
                          }
                        />
                      )}
                    </div>
                    {speaker.topic && (
                      <span class="text-sm text-accent-base">
                        {speaker.topic}
                      </span>
                    )}
                  </div>
                ))}
              </div>
            </div>
          </div>
        )
      }

      {/* Sponsors Section */}
      {
        validSponsors.length > 0 && (
          <div class="sponsors-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                SPONSORS
              </h3>
              <div class="space-y-4">
                {Object.entries(sponsorsByLevel).map(
                  ([level, sponsors]) =>
                    sponsors.length > 0 && (
                      <div>
                        <h4 class="text-xs font-medium mb-2 text-color-500 capitalize">
                          {level}
                        </h4>
                        <div class="flex flex-wrap gap-2">
                          {sponsors.map((sponsor) => (
                            <OrganizationChip
                              partnerId={sponsor.partnerId}
                              role={level !== "supporter" ? `${level.charAt(0).toUpperCase() + level.slice(1)} Sponsor` : "Sponsor"}
                            />
                          ))}
                        </div>
                      </div>
                    ),
                )}
              </div>
            </div>
          </div>
        )
      }
    </Fragment>

    {/* Tags and Topics */}
    <Fragment slot="tags">
      {/* Tags Section */}
      {
        data.tags && data.tags.length > 0 && (
          <div class="tags-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                TAGS
              </h3>
              <div class="flex flex-wrap gap-2">
                {data.tags.map((tag: string) => (
                  <a
                    href={`/events/tags/${tag}`}
                    class="inline-flex items-center gap-1 px-3 py-1.5 bg-accent-one/10 hover:bg-accent-one/20 rounded-lg text-sm text-accent-base transition-colors"
                  >
                    <Icon name="solar:hashtag-line-duotone" class="w-3 h-3" />
                    {tag}
                  </a>
                ))}
              </div>
            </div>
          </div>
        )
      }

      {/* Topics & Tracks */}
      {
        ((data.topics && data.topics.length > 0) ||
          (data.tracks && data.tracks.length > 0)) && (
          <div class="topics-tracks-section mb-8">
            <div class="bg-gradient-to-br from-surface-lighter to-surface rounded-xl border border-accent-one/20 p-6">
              {data.topics && data.topics.length > 0 && (
                <>
                  <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                    TOPICS
                  </h3>
                  <div class="flex flex-wrap gap-2 mb-4">
                    {data.topics.map((topic: string) => (
                      <span class="px-3 py-1.5 bg-accent-two/10 rounded-lg text-sm text-accent-base">
                        {topic}
                      </span>
                    ))}
                  </div>
                </>
              )}

              {data.tracks && data.tracks.length > 0 && (
                <>
                  <h3 class="text-xs font-semibold mb-3 text-accent-base uppercase tracking-wider">
                    TRACKS
                  </h3>
                  <div class="flex flex-wrap gap-2">
                    {data.tracks.map((track: string) => (
                      <span class="px-3 py-1.5 bg-accent-one/10 rounded-lg text-sm text-accent-base">
                        {track}
                      </span>
                    ))}
                  </div>
                </>
              )}
            </div>
          </div>
        )
      }
    </Fragment>

    {/* Main content from MDX file */}
    <!-- <Content /> -->

    {/* Related Events */}
    <Fragment slot="related">
      {
        relatedEvents && relatedEvents.length > 0 && (
          <RelatedItemsGrid
            client:load
            title="Related Events"
            subtitle="Similar upcoming and past events"
            items={
              relatedEvents.map((event) => ({
                id: event.id,
                data: {
                  name: event.data.name,
                  title: undefined,
                  displayName: event.data.displayName,
                  description: event.data.description,
                  abstract: undefined,
                  status: undefined,
                  type: event.data.type,
                  category: undefined,
                  featured: event.data.featured,
                  images: event.data.images,
                  avatar: undefined,
                  logo: undefined,
                  thumbnail: undefined,
                  banner: event.data.images?.hero,
                  links: event.data.links,
                  startDate: event.data.startDate,
                  endDate: event.data.endDate,
                  shortDescription: `${formatLabels[event.data.format]} • ${event.data.location.city}`,
                },
              })) as any
            }
            itemType="events"
            columns={3}
          />
        )
      }
    </Fragment>
  </BaseDetailLayout>
</PageLayout>
