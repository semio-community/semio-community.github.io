{"version":3,"file":"ParallaxHexBackground.Bxtlb6O-.js","sources":["../../node_modules/motion-dom/dist/es/scroll/observe.mjs","../../node_modules/motion-dom/dist/es/utils/transform.mjs","../../node_modules/motion-dom/dist/es/value/follow-value.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/utils/can-use-native-timeline.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/utils/get-timeline.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/attach-animation.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/attach-function.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/index.mjs","../../node_modules/framer-motion/dist/es/value/use-scroll.mjs","../../node_modules/framer-motion/dist/es/value/use-motion-value.mjs","../../node_modules/framer-motion/dist/es/value/use-combine-values.mjs","../../node_modules/framer-motion/dist/es/value/use-computed.mjs","../../node_modules/framer-motion/dist/es/value/use-transform.mjs","../../node_modules/framer-motion/dist/es/value/use-follow-value.mjs","../../node_modules/framer-motion/dist/es/value/use-spring.mjs","../../src/components/background/ParallaxHexBackground.tsx"],"sourcesContent":["import { frame, cancelFrame } from '../frameloop/frame.mjs';\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.preUpdate(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nexport { observeTimeline };\n//# sourceMappingURL=observe.mjs.map\n","import { interpolate } from './interpolate.mjs';\n\nfunction transform(...args) {\n    const useImmediate = !Array.isArray(args[0]);\n    const argOffset = useImmediate ? 0 : -1;\n    const inputValue = args[0 + argOffset];\n    const inputRange = args[1 + argOffset];\n    const outputRange = args[2 + argOffset];\n    const options = args[3 + argOffset];\n    const interpolator = interpolate(inputRange, outputRange, options);\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nexport { transform };\n//# sourceMappingURL=transform.mjs.map\n","import { motionValue } from './index.mjs';\nimport { JSAnimation } from '../animation/JSAnimation.mjs';\nimport { isMotionValue } from './utils/is-motion-value.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\n/**\n * Create a `MotionValue` that animates to its latest value using any transition type.\n * Can either be a value or track another `MotionValue`.\n *\n * ```jsx\n * const x = motionValue(0)\n * const y = followValue(x, { type: \"spring\", stiffness: 300 })\n * // or with tween\n * const z = followValue(x, { type: \"tween\", duration: 0.5, ease: \"easeOut\" })\n * ```\n *\n * @param source - Initial value or MotionValue to track\n * @param options - Animation transition options\n * @returns `MotionValue`\n *\n * @public\n */\nfunction followValue(source, options) {\n    const initialValue = isMotionValue(source) ? source.get() : source;\n    const value = motionValue(initialValue);\n    attachFollow(value, source, options);\n    return value;\n}\n/**\n * Attach an animation to a MotionValue that will animate whenever the value changes.\n * Similar to attachSpring but supports any transition type (spring, tween, inertia, etc.)\n *\n * @param value - The MotionValue to animate\n * @param source - Initial value or MotionValue to track\n * @param options - Animation transition options\n * @returns Cleanup function\n *\n * @public\n */\nfunction attachFollow(value, source, options = {}) {\n    const initialValue = value.get();\n    let activeAnimation = null;\n    let latestValue = initialValue;\n    let latestSetter;\n    const unit = typeof initialValue === \"string\"\n        ? initialValue.replace(/[\\d.-]/g, \"\")\n        : undefined;\n    const stopAnimation = () => {\n        if (activeAnimation) {\n            activeAnimation.stop();\n            activeAnimation = null;\n        }\n    };\n    const startAnimation = () => {\n        stopAnimation();\n        const currentValue = asNumber(value.get());\n        const targetValue = asNumber(latestValue);\n        // Don't animate if we're already at the target\n        if (currentValue === targetValue) {\n            return;\n        }\n        activeAnimation = new JSAnimation({\n            keyframes: [currentValue, targetValue],\n            velocity: value.getVelocity(),\n            // Default to spring if no type specified (matches useSpring behavior)\n            type: \"spring\",\n            restDelta: 0.001,\n            restSpeed: 0.01,\n            ...options,\n            onUpdate: latestSetter,\n        });\n    };\n    value.attach((v, set) => {\n        latestValue = v;\n        latestSetter = (latest) => set(parseValue(latest, unit));\n        frame.postRender(() => {\n            startAnimation();\n            value[\"events\"].animationStart?.notify();\n            activeAnimation?.then(() => {\n                value[\"events\"].animationComplete?.notify();\n            });\n        });\n    }, stopAnimation);\n    if (isMotionValue(source)) {\n        const removeSourceOnChange = source.on(\"change\", (v) => value.set(parseValue(v, unit)));\n        const removeValueOnDestroy = value.on(\"destroy\", removeSourceOnChange);\n        return () => {\n            removeSourceOnChange();\n            removeValueOnDestroy();\n        };\n    }\n    return stopAnimation;\n}\nfunction parseValue(v, unit) {\n    return unit ? v + unit : v;\n}\nfunction asNumber(v) {\n    return typeof v === \"number\" ? v : parseFloat(v);\n}\n\nexport { attachFollow, followValue };\n//# sourceMappingURL=follow-value.mjs.map\n","import { progress, velocityPerSecond } from 'motion-utils';\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[`scroll${position}`];\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nexport { createScrollInfo, updateScrollInfo };\n//# sourceMappingURL=info.mjs.map\n","import { isHTMLElement } from 'motion-dom';\n\nfunction calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n//# sourceMappingURL=inset.mjs.map\n","const namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nexport { namedEdges, resolveEdge };\n//# sourceMappingURL=edge.mjs.map\n","import { resolveEdge, namedEdges } from './edge.mjs';\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };\n//# sourceMappingURL=offset.mjs.map\n","const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nexport { ScrollOffset };\n//# sourceMappingURL=presets.mjs.map\n","import { interpolate, defaultOffset } from 'motion-dom';\nimport { clamp } from 'motion-utils';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n\nexport { resolveOffsets };\n//# sourceMappingURL=index.mjs.map\n","import { warnOnce } from 'motion-utils';\nimport { updateScrollInfo } from './info.mjs';\nimport { resolveOffsets } from './offsets/index.mjs';\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info);\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nexport { createOnScrollHandler };\n//# sourceMappingURL=on-scroll-handler.mjs.map\n","import { resize, frame, cancelFrame, frameData } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { createScrollInfo } from './info.mjs';\nimport { createOnScrollHandler } from './on-scroll-handler.mjs';\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst scrollSize = new WeakMap();\nconst dimensionCheckProcesses = new WeakMap();\nconst getEventTarget = (element) => element === document.scrollingElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.scrollingElement, trackContentSize = false, ...options } = {}) {\n    if (!container)\n        return noop;\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp);\n            }\n            frame.preUpdate(notifyAll);\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify();\n            }\n        };\n        const listener = () => frame.read(measureAll);\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener);\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener);\n        listener();\n    }\n    /**\n     * Enable content size tracking if requested and not already enabled.\n     */\n    if (trackContentSize && !dimensionCheckProcesses.has(container)) {\n        const listener = scrollListeners.get(container);\n        // Store initial scroll dimensions (object is reused to avoid allocation)\n        const size = {\n            width: container.scrollWidth,\n            height: container.scrollHeight,\n        };\n        scrollSize.set(container, size);\n        // Add frame-based scroll dimension checking to detect content changes\n        const checkScrollDimensions = () => {\n            const newWidth = container.scrollWidth;\n            const newHeight = container.scrollHeight;\n            if (size.width !== newWidth || size.height !== newHeight) {\n                listener();\n                size.width = newWidth;\n                size.height = newHeight;\n            }\n        };\n        // Schedule with keepAlive=true to run every frame\n        const dimensionCheckProcess = frame.read(checkScrollDimensions, true);\n        dimensionCheckProcesses.set(container, dimensionCheckProcess);\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            resizeListeners.get(container)?.();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n        // Clean up scroll dimension checking\n        const dimensionCheckProcess = dimensionCheckProcesses.get(container);\n        if (dimensionCheckProcess) {\n            cancelFrame(dimensionCheckProcess);\n            dimensionCheckProcesses.delete(container);\n        }\n        scrollSize.delete(container);\n    };\n}\n\nexport { scrollInfo };\n//# sourceMappingURL=track.mjs.map\n","import { supportsScrollTimeline } from 'motion-dom';\n\nfunction canUseNativeTimeline(target) {\n    return (typeof window !== \"undefined\" && !target && supportsScrollTimeline());\n}\n\nexport { canUseNativeTimeline };\n//# sourceMappingURL=can-use-native-timeline.mjs.map\n","import { scrollInfo } from '../track.mjs';\nimport { canUseNativeTimeline } from './can-use-native-timeline.mjs';\n\nconst timelineCache = new Map();\nfunction scrollTimelineFallback(options) {\n    const currentTime = { value: 0 };\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis].progress * 100;\n    }, options);\n    return { currentTime, cancel };\n}\nfunction getTimeline({ source, container, ...options }) {\n    const { axis } = options;\n    if (source)\n        container = source;\n    const containerCache = timelineCache.get(container) ?? new Map();\n    timelineCache.set(container, containerCache);\n    const targetKey = options.target ?? \"self\";\n    const targetCache = containerCache.get(targetKey) ?? {};\n    const axisKey = axis + (options.offset ?? []).join(\",\");\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            canUseNativeTimeline(options.target)\n                ? new ScrollTimeline({ source: container, axis })\n                : scrollTimelineFallback({ container, ...options });\n    }\n    return targetCache[axisKey];\n}\n\nexport { getTimeline };\n//# sourceMappingURL=get-timeline.mjs.map\n","import { observeTimeline } from 'motion-dom';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\nfunction attachToAnimation(animation, options) {\n    const timeline = getTimeline(options);\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause();\n            return observeTimeline((progress) => {\n                valueAnimation.time =\n                    valueAnimation.iterationDuration * progress;\n            }, timeline);\n        },\n    });\n}\n\nexport { attachToAnimation };\n//# sourceMappingURL=attach-animation.mjs.map\n","import { observeTimeline } from 'motion-dom';\nimport { scrollInfo } from './track.mjs';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll) {\n    return onScroll.length === 2;\n}\nfunction attachToFunction(onScroll, options) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis].progress, info);\n        }, options);\n    }\n    else {\n        return observeTimeline(onScroll, getTimeline(options));\n    }\n}\n\nexport { attachToFunction };\n//# sourceMappingURL=attach-function.mjs.map\n","import { noop } from 'motion-utils';\nimport { attachToAnimation } from './attach-animation.mjs';\nimport { attachToFunction } from './attach-function.mjs';\n\nfunction scroll(onScroll, { axis = \"y\", container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    const optionsWithDefaults = { axis, container, ...options };\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults);\n}\n\nexport { scroll };\n//# sourceMappingURL=index.mjs.map\n","\"use client\";\nimport { motionValue } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { useRef, useCallback, useEffect } from 'react';\nimport { scroll } from '../render/dom/scroll/index.mjs';\nimport { canUseNativeTimeline } from '../render/dom/scroll/utils/can-use-native-timeline.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\n\nconst createScrollMotionValues = () => ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n});\nconst isRefPending = (ref) => {\n    if (!ref)\n        return false;\n    return !ref.current;\n};\nfunction makeAccelerateConfig(axis, options, container) {\n    return {\n        factory: (animation) => scroll(animation, { ...options, axis, container }),\n        times: [0, 1],\n        keyframes: [0, 1],\n        ease: (v) => v,\n        duration: 1,\n    };\n}\nfunction useScroll({ container, target, ...options } = {}) {\n    const values = useConstant(createScrollMotionValues);\n    if (!target && canUseNativeTimeline()) {\n        const resolvedContainer = container?.current || undefined;\n        values.scrollXProgress.accelerate = makeAccelerateConfig(\"x\", options, resolvedContainer);\n        values.scrollYProgress.accelerate = makeAccelerateConfig(\"y\", options, resolvedContainer);\n    }\n    const scrollAnimation = useRef(null);\n    const needsStart = useRef(false);\n    const start = useCallback(() => {\n        scrollAnimation.current = scroll((_progress, { x, y, }) => {\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, {\n            ...options,\n            container: container?.current || undefined,\n            target: target?.current || undefined,\n        });\n        return () => {\n            scrollAnimation.current?.();\n        };\n    }, [container, target, JSON.stringify(options.offset)]);\n    useIsomorphicLayoutEffect(() => {\n        needsStart.current = false;\n        if (isRefPending(container) || isRefPending(target)) {\n            needsStart.current = true;\n            return;\n        }\n        else {\n            return start();\n        }\n    }, [start]);\n    useEffect(() => {\n        if (needsStart.current) {\n            invariant(!isRefPending(container), \"Container ref is defined but not hydrated\", \"use-scroll-ref\");\n            invariant(!isRefPending(target), \"Target ref is defined but not hydrated\", \"use-scroll-ref\");\n            return start();\n        }\n        else {\n            return;\n        }\n    }, [start]);\n    return values;\n}\n\nexport { useScroll };\n//# sourceMappingURL=use-scroll.mjs.map\n","\"use client\";\nimport { motionValue } from 'motion-dom';\nimport { useContext, useState, useEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n//# sourceMappingURL=use-motion-value.mjs.map\n","\"use client\";\nimport { cancelFrame, frame } from 'motion-dom';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    const value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    const updateValue = () => value.set(combineValues());\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useIsomorphicLayoutEffect(() => {\n        const scheduleUpdate = () => frame.preRender(updateValue, false, true);\n        const subscriptions = values.map((v) => v.on(\"change\", scheduleUpdate));\n        return () => {\n            subscriptions.forEach((unsubscribe) => unsubscribe());\n            cancelFrame(updateValue);\n        };\n    });\n    return value;\n}\n\nexport { useCombineMotionValues };\n//# sourceMappingURL=use-combine-values.mjs.map\n","\"use client\";\nimport { collectMotionValues } from 'motion-dom';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\n\nfunction useComputed(compute) {\n    /**\n     * Open session of collectMotionValues. Any MotionValue that calls get()\n     * will be saved into this array.\n     */\n    collectMotionValues.current = [];\n    compute();\n    const value = useCombineMotionValues(collectMotionValues.current, compute);\n    /**\n     * Synchronously close session of collectMotionValues.\n     */\n    collectMotionValues.current = undefined;\n    return value;\n}\n\nexport { useComputed };\n//# sourceMappingURL=use-computed.mjs.map\n","\"use client\";\nimport { transform } from 'motion-dom';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\nimport { useComputed } from './use-computed.mjs';\n\nfunction useTransform(input, inputRangeOrTransformer, outputRangeOrMap, options) {\n    if (typeof input === \"function\") {\n        return useComputed(input);\n    }\n    /**\n     * Detect if outputRangeOrMap is an output map (object with keys)\n     * rather than an output range (array).\n     */\n    const isOutputMap = outputRangeOrMap !== undefined &&\n        !Array.isArray(outputRangeOrMap) &&\n        typeof inputRangeOrTransformer !== \"function\";\n    if (isOutputMap) {\n        return useMapTransform(input, inputRangeOrTransformer, outputRangeOrMap, options);\n    }\n    const outputRange = outputRangeOrMap;\n    const transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    const result = Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], ([latest]) => transformer(latest));\n    const inputAccelerate = !Array.isArray(input)\n        ? input.accelerate\n        : undefined;\n    if (inputAccelerate &&\n        !inputAccelerate.isTransformed &&\n        typeof inputRangeOrTransformer !== \"function\" &&\n        Array.isArray(outputRangeOrMap) &&\n        options?.clamp !== false) {\n        result.accelerate = {\n            ...inputAccelerate,\n            times: inputRangeOrTransformer,\n            keyframes: outputRangeOrMap,\n            isTransformed: true,\n            ...(options?.ease ? { ease: options.ease } : {}),\n        };\n    }\n    return result;\n}\nfunction useListTransform(values, transformer) {\n    const latest = useConstant(() => []);\n    return useCombineMotionValues(values, () => {\n        latest.length = 0;\n        const numValues = values.length;\n        for (let i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\nfunction useMapTransform(inputValue, inputRange, outputMap, options) {\n    /**\n     * Capture keys once to ensure hooks are called in consistent order.\n     */\n    const keys = useConstant(() => Object.keys(outputMap));\n    const output = useConstant(() => ({}));\n    for (const key of keys) {\n        output[key] = useTransform(inputValue, inputRange, outputMap[key], options);\n    }\n    return output;\n}\n\nexport { useTransform };\n//# sourceMappingURL=use-transform.mjs.map\n","\"use client\";\nimport { attachFollow, isMotionValue } from 'motion-dom';\nimport { useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\nimport { useTransform } from './use-transform.mjs';\n\nfunction useFollowValue(source, options = {}) {\n    const { isStatic } = useContext(MotionConfigContext);\n    const getFromSource = () => (isMotionValue(source) ? source.get() : source);\n    // isStatic will never change, allowing early hooks return\n    if (isStatic) {\n        return useTransform(getFromSource);\n    }\n    const value = useMotionValue(getFromSource());\n    useInsertionEffect(() => {\n        return attachFollow(value, source, options);\n    }, [value, JSON.stringify(options)]);\n    return value;\n}\n\nexport { useFollowValue };\n//# sourceMappingURL=use-follow-value.mjs.map\n","\"use client\";\nimport { useFollowValue } from './use-follow-value.mjs';\n\nfunction useSpring(source, options = {}) {\n    return useFollowValue(source, { type: \"spring\", ...options });\n}\n\nexport { useSpring };\n//# sourceMappingURL=use-spring.mjs.map\n","import React, { useEffect, useMemo, useState } from \"react\";\nimport {\n  motion,\n  useMotionValue,\n  useScroll,\n  useSpring,\n  useTransform,\n} from \"motion/react\";\n\n/**\n * ParallaxHexBackground\n *\n * Renders a fixed, full-viewport background of hexagons at varying \"depths\".\n * As the page scrolls, each hexagon translates vertically at a fraction of the\n * scroll distance to create a parallax effect:\n *  - Near hexagons (larger) move more with the scroll (appear closer).\n *  - Far hexagons (smaller) move less (appear farther).\n *\n * Positions and sizes are generated from a seeded PRNG so the layout is\n * semi-stable across renders (e.g., seeded by day).\n *\n * Usage:\n *   <ParallaxHexBackground />\n *\n * Notes:\n * - The container is fixed and pointer-events are disabled so it sits behind content.\n * - Colors are subtle by default; override via the `palette` prop if desired.\n */\n\nexport interface ParallaxHexBackgroundProps {\n  /**\n   * Total number of hexagons (distributed across depth layers).\n   * Default: 48\n   */\n  count?: number;\n  /**\n   * Seed for randomization; defaults to YYYY-MM-DD (current date).\n   * Provide a string or number for stable layout between reloads.\n   */\n  seed?: string | number;\n  /**\n   * How many viewport heights (vh) to cover vertically above/below the viewport.\n   * Example: with verticalSpanVh = 220, hexes may appear from -20vh to 200vh.\n   * Default: 220\n   */\n  verticalSpanVh?: number;\n  /**\n   * Expand horizontal range beyond the viewport in vw (e.g. -10..110) to avoid edges.\n   * Default: { min: -10, max: 110 }\n   */\n  horizontalRangeVw?: { min: number; max: number };\n  /**\n   * Colors for strokes/fills. You can pass hex strings or rgba strings.\n   * The renderer will apply strokeOpacity/fillOpacity per hex.\n   * Default: brand-inspired palette.\n   */\n  palette?: string[];\n  /**\n   * Opacity ranges applied per hex. Values are multiplied with depth-based factors.\n   * Default: { stroke: [0.25, 0.55], fill: [0.05, 0.18] }\n   */\n  opacity?: { stroke: [number, number]; fill: [number, number] };\n  /**\n   * Optional className for outer fixed container.\n   */\n  className?: string;\n}\n\ntype GlyphSpec = {\n  id: string;\n  xVw: number; // 0..100 (or slightly outside per range)\n  yVh: number; // -buffer..100+buffer\n  size: number; // px (used to compute scale)\n  rotationDeg: number; // 0 | 120 | 240\n  variant: \"primary\" | \"secondary\" | \"tertiary\";\n  parallax: number; // 0..1 (1 moves with content, 0 is static)\n  zIndex: number; // 1..3\n  strokeOpacity: number;\n  fillOpacity: number;\n};\n\n/** PRNG (Mulberry32) with string/number seed support */\nfunction createRng(seed: string | number | undefined): () => number {\n  let h = 2166136261 >>> 0;\n  const s = String(seed ?? new Date().toISOString().slice(0, 10));\n  for (let i = 0; i < s.length; i++) {\n    h ^= s.charCodeAt(i);\n    h = Math.imul(h, 16777619);\n  }\n  let a = (h ^ 0x85ebca6b) >>> 0;\n  return function mulberry32() {\n    a |= 0;\n    a = (a + 0x6d2b79f5) | 0;\n    let t = Math.imul(a ^ (a >>> 15), 1 | a);\n    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n  };\n}\n\n/** Sample in [min, max) using rng() */\nfunction rndIn(rng: () => number, min: number, max: number) {\n  return min + rng() * (max - min);\n}\n\n/** Pick one from array using rng() */\n\nfunction generateGlyphs({\n  count,\n  seed,\n  palette,\n  verticalSpanVh,\n  horizontalRangeVw,\n  opacity,\n}: Required<\n  Pick<\n    ParallaxHexBackgroundProps,\n    | \"count\"\n    | \"seed\"\n    | \"palette\"\n    | \"verticalSpanVh\"\n    | \"horizontalRangeVw\"\n    | \"opacity\"\n  >\n>): GlyphSpec[] {\n  const rng = createRng(seed);\n\n  // Depth bands: near/mid/far proportions\n  const nearCount = Math.round(count * 0.22);\n  const midCount = Math.round(count * 0.34);\n  const farCount = Math.max(0, count - nearCount - midCount);\n\n  const result: GlyphSpec[] = [];\n\n  const bands: Array<{\n    n: number;\n    sizePx: [number, number];\n    parallax: [number, number];\n    z: number;\n    strokeScale: number;\n    fillScale: number;\n  }> = [\n    // Near: larger, moves more, foreground\n    {\n      n: nearCount,\n      sizePx: [72, 96],\n      parallax: [0.65, 1.0],\n      z: 3,\n      strokeScale: 1.0,\n      fillScale: 1.0,\n    },\n    // Mid\n    {\n      n: midCount,\n      sizePx: [42, 92],\n      parallax: [0.35, 0.6],\n      z: 2,\n      strokeScale: 0.9,\n      fillScale: 0.9,\n    },\n    // Far: smaller, moves less, background\n    {\n      n: farCount,\n      sizePx: [36, 48],\n      parallax: [0.08, 0.3],\n      z: 1,\n      strokeScale: 0.8,\n      fillScale: 0.8,\n    },\n  ];\n\n  const variants: Array<\"primary\" | \"secondary\" | \"tertiary\"> = [\n    \"primary\",\n    \"secondary\",\n    \"tertiary\",\n  ];\n\n  for (const band of bands) {\n    for (let i = 0; i < band.n; i++) {\n      const u = rng();\n      const t = band.z === 3 ? Math.sqrt(u) : band.z === 1 ? u * u : u;\n      const size = band.sizePx[0] + (band.sizePx[1] - band.sizePx[0]) * t;\n      const parallax = rndIn(rng, band.parallax[0], band.parallax[1]);\n      const xVw = rndIn(rng, horizontalRangeVw.min, horizontalRangeVw.max);\n      const yVh = rndIn(rng, -verticalSpanVh * 0.1, 100 + verticalSpanVh * 0.8); // spread above/below\n      const variantIndex =\n        Math.floor(rng() * variants.length) % variants.length;\n      const variant = variants[variantIndex] ?? \"primary\";\n      const rotationDeg =\n        variant === \"primary\" ? 0 : variant === \"secondary\" ? 120 : 240;\n\n      const strokeOpacity =\n        rndIn(rng, opacity.stroke[0], opacity.stroke[1]) * band.strokeScale;\n      const fillOpacity =\n        rndIn(rng, opacity.fill[0], opacity.fill[1]) * band.fillScale;\n\n      result.push({\n        id: `${band.z}-${i}-${Math.floor(rng() * 1e9)}`,\n        xVw,\n        yVh,\n        size,\n        rotationDeg,\n        variant,\n        parallax,\n        zIndex: band.z,\n        strokeOpacity,\n        fillOpacity,\n      });\n    }\n  }\n\n  return result;\n}\n\n/** Brand glyph path and dimensions (lifted from the legacy GlyphField.astro) */\nconst GLYPH_PATH_D =\n  \"M0.55,10.626L18.002,0.55L35.456,10.627L35.472,30.771L24.893,36.879L29.541,39.562C29.543,39.564 29.546,39.565 29.548,39.567L30.716,40.241L23.83,44.202L14.575,38.873L0.55,30.778L0.55,10.626Z\";\nconst GLYPH_W = 37;\nconst GLYPH_H = 45;\n\n/** Color helpers (align with GlyphField variant colors) */\nfunction getStrokeColor(\n  variant: \"primary\" | \"secondary\" | \"tertiary\",\n  grayscale = false,\n): string {\n  if (grayscale) {\n    switch (variant) {\n      case \"primary\":\n        return \"#d4d4d4\";\n      case \"secondary\":\n        return \"#bdbdbd\";\n      case \"tertiary\":\n        return \"#a3a3a3\";\n    }\n  }\n  switch (variant) {\n    case \"primary\":\n      return \"#EF6129\"; // red-orange\n    case \"secondary\":\n      return \"#FF9E00\"; // yellow-orange\n    case \"tertiary\":\n      return \"#50C4B6\"; // teal\n  }\n}\n\nfunction getFillColor(\n  variant: \"primary\" | \"secondary\" | \"tertiary\",\n  grayscale = false,\n): string {\n  if (grayscale) {\n    switch (variant) {\n      case \"primary\":\n        return \"#d4d4d4\";\n      case \"secondary\":\n        return \"#bdbdbd\";\n      case \"tertiary\":\n        return \"#a3a3a3\";\n    }\n  }\n  switch (variant) {\n    case \"primary\":\n      return \"#EF6129\";\n    case \"secondary\":\n      return \"#FF9E00\";\n    case \"tertiary\":\n      return \"#50C4B6\";\n  }\n}\n\nconst MOBILE_UA_REGEX =\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone/i;\n\nfunction detectMobileDevice(): boolean {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n\n  const ua = navigator.userAgent || navigator.vendor || \"\";\n  if (MOBILE_UA_REGEX.test(ua)) {\n    return true;\n  }\n\n  if (\"maxTouchPoints\" in navigator && navigator.maxTouchPoints > 1) {\n    return true;\n  }\n\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.matchMedia === \"function\"\n  ) {\n    try {\n      if (window.matchMedia(\"(pointer: coarse)\").matches) {\n        return true;\n      }\n    } catch {\n      // ignore matchMedia failures\n    }\n  }\n\n  return false;\n}\n\nfunction Glyph({\n  spec,\n  virtualWidth,\n  virtualHeight,\n}: {\n  spec: GlyphSpec;\n  virtualWidth: number;\n  virtualHeight: number;\n}) {\n  // Near (parallax ~1) should be sharp; far (parallax small) slightly blurred.\n  // Depth-based blur: numeric per glyph (constant with respect to scroll)\n  const p = Math.max(0, Math.min(1, spec.parallax));\n  const nearBlur = 1; // px\n  const farBlur = 4; // px\n  const blurPx = farBlur - p * (farBlur - nearBlur);\n  const blurFilter = `blur(${blurPx}px)`;\n\n  const stroke = getStrokeColor(spec.variant);\n  const fill = getFillColor(spec.variant);\n\n  // Scale based on desired pixel size vs intrinsic glyph height\n  const s = spec.size / GLYPH_H;\n  const MAX_BLUR = 16;\n  const margin = MAX_BLUR;\n  const paddedSize = spec.size + margin * 2;\n\n  const baselineEdge = 100;\n  const extra = Math.max(0, virtualWidth / 16);\n  const adjustedVw = spec.xVw >= baselineEdge ? spec.xVw + extra : spec.xVw;\n  const leftPx = (adjustedVw / 100) * virtualWidth - margin;\n  const topPx = (spec.yVh / 100) * virtualHeight - margin;\n\n  return (\n    <div style={{ filter: blurFilter, WebkitFilter: blurFilter }}>\n      <svg\n        width={paddedSize}\n        height={paddedSize}\n        viewBox={`${-GLYPH_W / 2} ${-GLYPH_H / 2} ${GLYPH_W} ${GLYPH_H}`}\n        style={{\n          position: \"absolute\",\n          left: `${leftPx}px`,\n          top: `${topPx}px`,\n          zIndex: spec.zIndex,\n          opacity: 1,\n          pointerEvents: \"none\",\n          overflow: \"visible\",\n          willChange: \"transform, filter\",\n        }}\n        aria-hidden=\"true\"\n      >\n        <g\n          transform={`rotate(${spec.rotationDeg})`}\n          style={{ filter: blurFilter, WebkitFilter: blurFilter }}\n        >\n          <path\n            d={GLYPH_PATH_D}\n            fill={fill}\n            fillOpacity={spec.fillOpacity}\n            stroke={stroke}\n            strokeOpacity={spec.strokeOpacity}\n            strokeWidth={1}\n            vectorEffect=\"non-scaling-stroke\"\n            transform={`translate(${(-GLYPH_W / 2) * s}, ${(-GLYPH_H / 2) * s}) scale(${s})`}\n          />\n        </g>\n      </svg>\n    </div>\n  );\n}\n\nexport default function ParallaxHexBackground({\n  count = 48,\n  seed,\n  verticalSpanVh = 220,\n  horizontalRangeVw = { min: -10, max: 110 },\n  palette = [\"#50C4B6\", \"#FF9E00\", \"#EF6129\"], // teal, yellow-orange, red-orange\n  opacity = { stroke: [0.22, 0.55], fill: [0.05, 0.18] },\n  className = \"\",\n}: ParallaxHexBackgroundProps) {\n  const MIN_VIRTUAL_WIDTH = 768;\n  const MIN_VIRTUAL_HEIGHT = 960;\n  const VIEWPORT_THRESHOLD = 24;\n  const getInitialViewport = () => {\n    if (typeof window === \"undefined\") {\n      return { width: MIN_VIRTUAL_WIDTH, height: MIN_VIRTUAL_HEIGHT };\n    }\n    return {\n      width: window.innerWidth,\n      height: Math.max(MIN_VIRTUAL_HEIGHT, window.innerHeight),\n    };\n  };\n  const [viewport, setViewport] = useState(getInitialViewport);\n  const [isMobileDevice, setIsMobileDevice] = useState(() =>\n    detectMobileDevice(),\n  );\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n    let frame: number | null = null;\n    const handleResize = () => {\n      if (frame) cancelAnimationFrame(frame);\n      frame = requestAnimationFrame(() => {\n        const nextWidth = window.innerWidth;\n        const nextHeight = Math.max(MIN_VIRTUAL_HEIGHT, window.innerHeight);\n        setViewport((prev) => {\n          if (\n            Math.abs(prev.width - nextWidth) < VIEWPORT_THRESHOLD &&\n            Math.abs(prev.height - nextHeight) < VIEWPORT_THRESHOLD\n          ) {\n            return prev;\n          }\n          return { width: nextWidth, height: nextHeight };\n        });\n      });\n    };\n    window.addEventListener(\"resize\", handleResize, { passive: true });\n    window.visualViewport?.addEventListener(\"resize\", handleResize);\n    return () => {\n      if (frame) cancelAnimationFrame(frame);\n      window.removeEventListener(\"resize\", handleResize);\n      window.visualViewport?.removeEventListener(\"resize\", handleResize);\n    };\n  }, []);\n\n  useEffect(() => {\n    setIsMobileDevice(detectMobileDevice());\n  }, []);\n\n  const virtualWidth = Math.max(MIN_VIRTUAL_WIDTH, viewport.width);\n  const virtualHeight = Math.max(MIN_VIRTUAL_HEIGHT, viewport.height);\n  const isMobile = virtualWidth <= 768;\n  const effectiveCount = isMobile\n    ? Math.max(24, Math.round(count * 0.75))\n    : count;\n  const disableParallax = isMobileDevice;\n\n  const glyphs = useMemo(\n    () =>\n      generateGlyphs({\n        count: effectiveCount,\n        seed: seed ?? new Date().toISOString().slice(0, 10),\n        palette,\n        verticalSpanVh,\n        horizontalRangeVw,\n        opacity,\n      }).sort((a, b) => a.zIndex - b.zIndex), // ensure back-to-front rendering\n    [effectiveCount, seed, palette, verticalSpanVh, horizontalRangeVw, opacity],\n  );\n\n  const glyphBands = useMemo(() => {\n    const near: GlyphSpec[] = [];\n    const mid: GlyphSpec[] = [];\n    const far: GlyphSpec[] = [];\n    for (const glyph of glyphs) {\n      if (glyph.zIndex === 3) near.push(glyph);\n      else if (glyph.zIndex === 2) mid.push(glyph);\n      else far.push(glyph);\n    }\n    return { near, mid, far };\n  }, [glyphs]);\n\n  const nearParallax = 0.8;\n  const midParallax = 0.45;\n  const farParallax = 0.18;\n\n  // Subscribe to page scroll once and pass motion value to children\n  const { scrollY } = useScroll();\n  const smoothedScroll = useSpring(scrollY, {\n    stiffness: 250,\n    damping: 30,\n    mass: 0.2,\n  });\n  const staticScroll = useMotionValue(0);\n  const scrollSource = disableParallax\n    ? staticScroll\n    : isMobileDevice\n      ? smoothedScroll\n      : scrollY;\n  const nearY = useTransform(scrollSource, (v) => -v * nearParallax);\n  const midY = useTransform(scrollSource, (v) => -v * midParallax);\n  const farY = useTransform(scrollSource, (v) => -v * farParallax);\n\n  return (\n    <div\n      className={`pointer-events-none fixed inset-0 ${className}`}\n      aria-hidden=\"true\"\n    >\n      {[\n        { key: \"near\", mv: nearY, items: glyphBands.near },\n        { key: \"mid\", mv: midY, items: glyphBands.mid },\n        { key: \"far\", mv: farY, items: glyphBands.far },\n      ].map(({ key, mv, items }) =>\n        items.length ? (\n          <motion.div\n            key={key}\n            style={{\n              y: disableParallax ? 0 : mv,\n              position: \"absolute\",\n              inset: 0,\n              pointerEvents: \"none\",\n            }}\n            aria-hidden=\"true\"\n          >\n            {items.map((glyph) => (\n              <Glyph\n                key={glyph.id}\n                spec={glyph}\n                virtualWidth={virtualWidth}\n                virtualHeight={virtualHeight}\n              />\n            ))}\n          </motion.div>\n        ) : null,\n      )}\n    </div>\n  );\n}\n"],"names":["observeTimeline","update","timeline","prevProgress","onFrame","currentTime","progress","frame","cancelFrame","transform","args","useImmediate","argOffset","inputValue","inputRange","outputRange","options","interpolator","interpolate","attachFollow","value","source","initialValue","activeAnimation","latestValue","latestSetter","unit","stopAnimation","startAnimation","currentValue","asNumber","targetValue","JSAnimation","v","set","latest","parseValue","isMotionValue","removeSourceOnChange","removeValueOnDestroy","maxElapsed","createAxisInfo","createScrollInfo","keys","updateAxisInfo","element","axisName","info","time","axis","length","position","prev","prevTime","elapsed","velocityPerSecond","updateScrollInfo","calcInset","container","inset","current","isHTMLElement","svgBoundingBox","parentBoundingBox","x","y","svg","parent","namedEdges","resolveEdge","edge","delta","defaultOffset","resolveOffset","offset","containerLength","targetLength","targetInset","offsetDefinition","targetPoint","containerPoint","ScrollOffset","point","getTargetSize","target","resolveOffsets","lengthLabel","targetSize","containerSize","hasChanged","numOffsets","i","clamp","measure","node","createOnScrollHandler","onScroll","scrollListeners","resizeListeners","onScrollHandlers","scrollSize","dimensionCheckProcesses","getEventTarget","scrollInfo","trackContentSize","noop","containerHandlers","containerHandler","measureAll","handler","frameData","notifyAll","listener","resize","size","checkScrollDimensions","newWidth","newHeight","dimensionCheckProcess","currentHandlers","scrollListener","canUseNativeTimeline","supportsScrollTimeline","timelineCache","scrollTimelineFallback","cancel","getTimeline","containerCache","targetKey","targetCache","axisKey","attachToAnimation","animation","valueAnimation","isOnScrollWithInfo","attachToFunction","scroll","optionsWithDefaults","createScrollMotionValues","motionValue","isRefPending","ref","makeAccelerateConfig","useScroll","values","useConstant","resolvedContainer","scrollAnimation","useRef","needsStart","start","useCallback","_progress","useIsomorphicLayoutEffect","useEffect","invariant","useMotionValue","initial","isStatic","useContext","MotionConfigContext","setLatest","useState","useCombineMotionValues","combineValues","updateValue","scheduleUpdate","subscriptions","unsubscribe","useComputed","compute","collectMotionValues","useTransform","input","inputRangeOrTransformer","outputRangeOrMap","transformer","result","useListTransform","inputAccelerate","numValues","useFollowValue","getFromSource","useInsertionEffect","useSpring","createRng","seed","h","a","t","rndIn","rng","min","max","generateGlyphs","count","palette","verticalSpanVh","horizontalRangeVw","opacity","nearCount","midCount","farCount","bands","variants","band","u","parallax","xVw","yVh","variantIndex","variant","rotationDeg","strokeOpacity","fillOpacity","GLYPH_PATH_D","GLYPH_W","GLYPH_H","getStrokeColor","grayscale","getFillColor","MOBILE_UA_REGEX","detectMobileDevice","ua","Glyph","spec","virtualWidth","virtualHeight","p","nearBlur","farBlur","blurFilter","stroke","fill","s","margin","paddedSize","baselineEdge","extra","leftPx","topPx","jsx","ParallaxHexBackground","className","getInitialViewport","viewport","setViewport","isMobileDevice","setIsMobileDevice","handleResize","nextWidth","nextHeight","effectiveCount","disableParallax","glyphs","useMemo","b","glyphBands","near","mid","far","glyph","nearParallax","midParallax","farParallax","scrollY","smoothedScroll","staticScroll","scrollSource","nearY","midY","farY","key","mv","items","motion"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]}