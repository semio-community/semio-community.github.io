{"version":3,"file":"ParallaxHexBackground.BEgS86Sl.js","sources":["../../node_modules/motion-dom/dist/es/resize/handle-element.mjs","../../node_modules/motion-dom/dist/es/resize/handle-window.mjs","../../node_modules/motion-dom/dist/es/resize/index.mjs","../../node_modules/motion-dom/dist/es/scroll/observe.mjs","../../node_modules/motion-dom/dist/es/utils/transform.mjs","../../node_modules/motion-dom/dist/es/value/spring-value.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/utils/get-timeline.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/attach-animation.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/attach-function.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/index.mjs","../../node_modules/framer-motion/dist/es/value/use-scroll.mjs","../../node_modules/framer-motion/dist/es/value/use-motion-value.mjs","../../node_modules/framer-motion/dist/es/value/use-combine-values.mjs","../../node_modules/framer-motion/dist/es/value/use-computed.mjs","../../node_modules/framer-motion/dist/es/value/use-transform.mjs","../../node_modules/framer-motion/dist/es/value/use-spring.mjs","../../src/components/background/ParallaxHexBackground.tsx"],"sourcesContent":["import { isSVGElement } from '../utils/is-svg-element.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nconst getSize = (borderBoxAxis, svgAxis, htmlAxis) => (target, borderBoxSize) => {\n    if (borderBoxSize && borderBoxSize[0]) {\n        return borderBoxSize[0][(borderBoxAxis + \"Size\")];\n    }\n    else if (isSVGElement(target) && \"getBBox\" in target) {\n        return target.getBBox()[svgAxis];\n    }\n    else {\n        return target[htmlAxis];\n    }\n};\nconst getWidth = /*@__PURE__*/ getSize(\"inline\", \"width\", \"offsetWidth\");\nconst getHeight = /*@__PURE__*/ getSize(\"block\", \"height\", \"offsetHeight\");\nfunction notifyTarget({ target, borderBoxSize }) {\n    resizeHandlers.get(target)?.forEach((handler) => {\n        handler(target, {\n            get width() {\n                return getWidth(target, borderBoxSize);\n            },\n            get height() {\n                return getHeight(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer?.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers?.delete(handler);\n            if (!elementHandlers?.size) {\n                observer?.unobserve(element);\n            }\n        });\n    };\n}\n\nexport { resizeElement };\n","const windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const info = {\n            get width() {\n                return window.innerWidth;\n            },\n            get height() {\n                return window.innerHeight;\n            },\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size &&\n            typeof windowResizeHandler === \"function\") {\n            window.removeEventListener(\"resize\", windowResizeHandler);\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nexport { resizeWindow };\n","import { resizeElement } from './handle-element.mjs';\nimport { resizeWindow } from './handle-window.mjs';\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\nexport { resize };\n","import { frame, cancelFrame } from '../frameloop/frame.mjs';\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.preUpdate(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nexport { observeTimeline };\n","import { interpolate } from './interpolate.mjs';\n\nfunction transform(...args) {\n    const useImmediate = !Array.isArray(args[0]);\n    const argOffset = useImmediate ? 0 : -1;\n    const inputValue = args[0 + argOffset];\n    const inputRange = args[1 + argOffset];\n    const outputRange = args[2 + argOffset];\n    const options = args[3 + argOffset];\n    const interpolator = interpolate(inputRange, outputRange, options);\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nexport { transform };\n","import { motionValue } from './index.mjs';\nimport { JSAnimation } from '../animation/JSAnimation.mjs';\nimport { isMotionValue } from './utils/is-motion-value.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\n/**\n * Create a `MotionValue` that animates to its latest value using a spring.\n * Can either be a value or track another `MotionValue`.\n *\n * ```jsx\n * const x = motionValue(0)\n * const y = transformValue(() => x.get() * 2) // double x\n * ```\n *\n * @param transformer - A transform function. This function must be pure with no side-effects or conditional statements.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction springValue(source, options) {\n    const initialValue = isMotionValue(source) ? source.get() : source;\n    const value = motionValue(initialValue);\n    attachSpring(value, source, options);\n    return value;\n}\nfunction attachSpring(value, source, options) {\n    const initialValue = value.get();\n    let activeAnimation = null;\n    let latestValue = initialValue;\n    let latestSetter;\n    const unit = typeof initialValue === \"string\"\n        ? initialValue.replace(/[\\d.-]/g, \"\")\n        : undefined;\n    const stopAnimation = () => {\n        if (activeAnimation) {\n            activeAnimation.stop();\n            activeAnimation = null;\n        }\n    };\n    const startAnimation = () => {\n        stopAnimation();\n        activeAnimation = new JSAnimation({\n            keyframes: [asNumber(value.get()), asNumber(latestValue)],\n            velocity: value.getVelocity(),\n            type: \"spring\",\n            restDelta: 0.001,\n            restSpeed: 0.01,\n            ...options,\n            onUpdate: latestSetter,\n        });\n    };\n    value.attach((v, set) => {\n        latestValue = v;\n        latestSetter = (latest) => set(parseValue(latest, unit));\n        frame.postRender(startAnimation);\n    }, stopAnimation);\n    if (isMotionValue(source)) {\n        const removeSourceOnChange = source.on(\"change\", (v) => value.set(parseValue(v, unit)));\n        const removeValueOnDestroy = value.on(\"destroy\", removeSourceOnChange);\n        return () => {\n            removeSourceOnChange();\n            removeValueOnDestroy();\n        };\n    }\n    return stopAnimation;\n}\nfunction parseValue(v, unit) {\n    return unit ? v + unit : v;\n}\nfunction asNumber(v) {\n    return typeof v === \"number\" ? v : parseFloat(v);\n}\n\nexport { attachSpring, springValue };\n","import { progress, velocityPerSecond } from 'motion-utils';\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[`scroll${position}`];\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nexport { createScrollInfo, updateScrollInfo };\n","import { isHTMLElement } from 'motion-dom';\n\nfunction calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n","const namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nexport { namedEdges, resolveEdge };\n","import { resolveEdge, namedEdges } from './edge.mjs';\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };\n","const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nexport { ScrollOffset };\n","import { interpolate, defaultOffset } from 'motion-dom';\nimport { clamp } from 'motion-utils';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n\nexport { resolveOffsets };\n","import { warnOnce } from 'motion-utils';\nimport { updateScrollInfo } from './info.mjs';\nimport { resolveOffsets } from './offsets/index.mjs';\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info);\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nexport { createOnScrollHandler };\n","import { resize, frame, cancelFrame, frameData } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { createScrollInfo } from './info.mjs';\nimport { createOnScrollHandler } from './on-scroll-handler.mjs';\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.scrollingElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp);\n            }\n            frame.preUpdate(notifyAll);\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify();\n            }\n        };\n        const listener = () => frame.read(measureAll);\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n        listener();\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            resizeListeners.get(container)?.();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\n\nexport { scrollInfo };\n","import { supportsScrollTimeline } from 'motion-dom';\nimport { scrollInfo } from '../track.mjs';\n\nconst timelineCache = new Map();\nfunction scrollTimelineFallback(options) {\n    const currentTime = { value: 0 };\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis].progress * 100;\n    }, options);\n    return { currentTime, cancel };\n}\nfunction getTimeline({ source, container, ...options }) {\n    const { axis } = options;\n    if (source)\n        container = source;\n    const containerCache = timelineCache.get(container) ?? new Map();\n    timelineCache.set(container, containerCache);\n    const targetKey = options.target ?? \"self\";\n    const targetCache = containerCache.get(targetKey) ?? {};\n    const axisKey = axis + (options.offset ?? []).join(\",\");\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            !options.target && supportsScrollTimeline()\n                ? new ScrollTimeline({ source: container, axis })\n                : scrollTimelineFallback({ container, ...options });\n    }\n    return targetCache[axisKey];\n}\n\nexport { getTimeline };\n","import { observeTimeline } from 'motion-dom';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\nfunction attachToAnimation(animation, options) {\n    const timeline = getTimeline(options);\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause();\n            return observeTimeline((progress) => {\n                valueAnimation.time =\n                    valueAnimation.iterationDuration * progress;\n            }, timeline);\n        },\n    });\n}\n\nexport { attachToAnimation };\n","import { observeTimeline } from 'motion-dom';\nimport { scrollInfo } from './track.mjs';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll) {\n    return onScroll.length === 2;\n}\nfunction attachToFunction(onScroll, options) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis].progress, info);\n        }, options);\n    }\n    else {\n        return observeTimeline(onScroll, getTimeline(options));\n    }\n}\n\nexport { attachToFunction };\n","import { noop } from 'motion-utils';\nimport { attachToAnimation } from './attach-animation.mjs';\nimport { attachToFunction } from './attach-function.mjs';\n\nfunction scroll(onScroll, { axis = \"y\", container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    const optionsWithDefaults = { axis, container, ...options };\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults);\n}\n\nexport { scroll };\n","\"use client\";\nimport { motionValue } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { useRef, useCallback, useEffect } from 'react';\nimport { scroll } from '../render/dom/scroll/index.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\n\nconst createScrollMotionValues = () => ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n});\nconst isRefPending = (ref) => {\n    if (!ref)\n        return false;\n    return !ref.current;\n};\nfunction useScroll({ container, target, ...options } = {}) {\n    const values = useConstant(createScrollMotionValues);\n    const scrollAnimation = useRef(null);\n    const needsStart = useRef(false);\n    const start = useCallback(() => {\n        scrollAnimation.current = scroll((_progress, { x, y, }) => {\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, {\n            ...options,\n            container: container?.current || undefined,\n            target: target?.current || undefined,\n        });\n        return () => {\n            scrollAnimation.current?.();\n        };\n    }, [container, target, JSON.stringify(options.offset)]);\n    useIsomorphicLayoutEffect(() => {\n        needsStart.current = false;\n        if (isRefPending(container) || isRefPending(target)) {\n            needsStart.current = true;\n            return;\n        }\n        else {\n            return start();\n        }\n    }, [start]);\n    useEffect(() => {\n        if (needsStart.current) {\n            invariant(!isRefPending(container), \"Container ref is defined but not hydrated\", \"use-scroll-ref\");\n            invariant(!isRefPending(target), \"Target ref is defined but not hydrated\", \"use-scroll-ref\");\n            return start();\n        }\n        else {\n            return;\n        }\n    }, [start]);\n    return values;\n}\n\nexport { useScroll };\n","\"use client\";\nimport { motionValue } from 'motion-dom';\nimport { useContext, useState, useEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n","\"use client\";\nimport { cancelFrame, frame } from 'motion-dom';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    const value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    const updateValue = () => value.set(combineValues());\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useIsomorphicLayoutEffect(() => {\n        const scheduleUpdate = () => frame.preRender(updateValue, false, true);\n        const subscriptions = values.map((v) => v.on(\"change\", scheduleUpdate));\n        return () => {\n            subscriptions.forEach((unsubscribe) => unsubscribe());\n            cancelFrame(updateValue);\n        };\n    });\n    return value;\n}\n\nexport { useCombineMotionValues };\n","\"use client\";\nimport { collectMotionValues } from 'motion-dom';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\n\nfunction useComputed(compute) {\n    /**\n     * Open session of collectMotionValues. Any MotionValue that calls get()\n     * will be saved into this array.\n     */\n    collectMotionValues.current = [];\n    compute();\n    const value = useCombineMotionValues(collectMotionValues.current, compute);\n    /**\n     * Synchronously close session of collectMotionValues.\n     */\n    collectMotionValues.current = undefined;\n    return value;\n}\n\nexport { useComputed };\n","\"use client\";\nimport { transform } from 'motion-dom';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\nimport { useComputed } from './use-computed.mjs';\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    if (typeof input === \"function\") {\n        return useComputed(input);\n    }\n    const transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], ([latest]) => transformer(latest));\n}\nfunction useListTransform(values, transformer) {\n    const latest = useConstant(() => []);\n    return useCombineMotionValues(values, () => {\n        latest.length = 0;\n        const numValues = values.length;\n        for (let i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\nexport { useTransform };\n","\"use client\";\nimport { attachSpring, isMotionValue } from 'motion-dom';\nimport { useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\nimport { useTransform } from './use-transform.mjs';\n\nfunction useSpring(source, options = {}) {\n    const { isStatic } = useContext(MotionConfigContext);\n    const getFromSource = () => (isMotionValue(source) ? source.get() : source);\n    // isStatic will never change, allowing early hooks return\n    if (isStatic) {\n        return useTransform(getFromSource);\n    }\n    const value = useMotionValue(getFromSource());\n    useInsertionEffect(() => {\n        return attachSpring(value, source, options);\n    }, [value, JSON.stringify(options)]);\n    return value;\n}\n\nexport { useSpring };\n","import React, { useEffect, useMemo, useState } from \"react\";\nimport {\n  motion,\n  useMotionValue,\n  useScroll,\n  useSpring,\n  useTransform,\n} from \"motion/react\";\n\n/**\n * ParallaxHexBackground\n *\n * Renders a fixed, full-viewport background of hexagons at varying \"depths\".\n * As the page scrolls, each hexagon translates vertically at a fraction of the\n * scroll distance to create a parallax effect:\n *  - Near hexagons (larger) move more with the scroll (appear closer).\n *  - Far hexagons (smaller) move less (appear farther).\n *\n * Positions and sizes are generated from a seeded PRNG so the layout is\n * semi-stable across renders (e.g., seeded by day).\n *\n * Usage:\n *   <ParallaxHexBackground />\n *\n * Notes:\n * - The container is fixed and pointer-events are disabled so it sits behind content.\n * - Colors are subtle by default; override via the `palette` prop if desired.\n */\n\nexport interface ParallaxHexBackgroundProps {\n  /**\n   * Total number of hexagons (distributed across depth layers).\n   * Default: 48\n   */\n  count?: number;\n  /**\n   * Seed for randomization; defaults to YYYY-MM-DD (current date).\n   * Provide a string or number for stable layout between reloads.\n   */\n  seed?: string | number;\n  /**\n   * How many viewport heights (vh) to cover vertically above/below the viewport.\n   * Example: with verticalSpanVh = 220, hexes may appear from -20vh to 200vh.\n   * Default: 220\n   */\n  verticalSpanVh?: number;\n  /**\n   * Expand horizontal range beyond the viewport in vw (e.g. -10..110) to avoid edges.\n   * Default: { min: -10, max: 110 }\n   */\n  horizontalRangeVw?: { min: number; max: number };\n  /**\n   * Colors for strokes/fills. You can pass hex strings or rgba strings.\n   * The renderer will apply strokeOpacity/fillOpacity per hex.\n   * Default: brand-inspired palette.\n   */\n  palette?: string[];\n  /**\n   * Opacity ranges applied per hex. Values are multiplied with depth-based factors.\n   * Default: { stroke: [0.25, 0.55], fill: [0.05, 0.18] }\n   */\n  opacity?: { stroke: [number, number]; fill: [number, number] };\n  /**\n   * Optional className for outer fixed container.\n   */\n  className?: string;\n}\n\ntype GlyphSpec = {\n  id: string;\n  xVw: number; // 0..100 (or slightly outside per range)\n  yVh: number; // -buffer..100+buffer\n  size: number; // px (used to compute scale)\n  rotationDeg: number; // 0 | 120 | 240\n  variant: \"primary\" | \"secondary\" | \"tertiary\";\n  parallax: number; // 0..1 (1 moves with content, 0 is static)\n  zIndex: number; // 1..3\n  strokeOpacity: number;\n  fillOpacity: number;\n};\n\n/** PRNG (Mulberry32) with string/number seed support */\nfunction createRng(seed: string | number | undefined): () => number {\n  let h = 2166136261 >>> 0;\n  const s = String(seed ?? new Date().toISOString().slice(0, 10));\n  for (let i = 0; i < s.length; i++) {\n    h ^= s.charCodeAt(i);\n    h = Math.imul(h, 16777619);\n  }\n  let a = (h ^ 0x85ebca6b) >>> 0;\n  return function mulberry32() {\n    a |= 0;\n    a = (a + 0x6d2b79f5) | 0;\n    let t = Math.imul(a ^ (a >>> 15), 1 | a);\n    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n  };\n}\n\n/** Sample in [min, max) using rng() */\nfunction rndIn(rng: () => number, min: number, max: number) {\n  return min + rng() * (max - min);\n}\n\n/** Pick one from array using rng() */\n\nfunction generateGlyphs({\n  count,\n  seed,\n  palette,\n  verticalSpanVh,\n  horizontalRangeVw,\n  opacity,\n}: Required<\n  Pick<\n    ParallaxHexBackgroundProps,\n    | \"count\"\n    | \"seed\"\n    | \"palette\"\n    | \"verticalSpanVh\"\n    | \"horizontalRangeVw\"\n    | \"opacity\"\n  >\n>): GlyphSpec[] {\n  const rng = createRng(seed);\n\n  // Depth bands: near/mid/far proportions\n  const nearCount = Math.round(count * 0.22);\n  const midCount = Math.round(count * 0.34);\n  const farCount = Math.max(0, count - nearCount - midCount);\n\n  const result: GlyphSpec[] = [];\n\n  const bands: Array<{\n    n: number;\n    sizePx: [number, number];\n    parallax: [number, number];\n    z: number;\n    strokeScale: number;\n    fillScale: number;\n  }> = [\n    // Near: larger, moves more, foreground\n    {\n      n: nearCount,\n      sizePx: [72, 96],\n      parallax: [0.65, 1.0],\n      z: 3,\n      strokeScale: 1.0,\n      fillScale: 1.0,\n    },\n    // Mid\n    {\n      n: midCount,\n      sizePx: [42, 92],\n      parallax: [0.35, 0.6],\n      z: 2,\n      strokeScale: 0.9,\n      fillScale: 0.9,\n    },\n    // Far: smaller, moves less, background\n    {\n      n: farCount,\n      sizePx: [36, 48],\n      parallax: [0.08, 0.3],\n      z: 1,\n      strokeScale: 0.8,\n      fillScale: 0.8,\n    },\n  ];\n\n  const variants: Array<\"primary\" | \"secondary\" | \"tertiary\"> = [\n    \"primary\",\n    \"secondary\",\n    \"tertiary\",\n  ];\n\n  for (const band of bands) {\n    for (let i = 0; i < band.n; i++) {\n      const u = rng();\n      const t = band.z === 3 ? Math.sqrt(u) : band.z === 1 ? u * u : u;\n      const size = band.sizePx[0] + (band.sizePx[1] - band.sizePx[0]) * t;\n      const parallax = rndIn(rng, band.parallax[0], band.parallax[1]);\n      const xVw = rndIn(rng, horizontalRangeVw.min, horizontalRangeVw.max);\n      const yVh = rndIn(rng, -verticalSpanVh * 0.1, 100 + verticalSpanVh * 0.8); // spread above/below\n      const variantIndex =\n        Math.floor(rng() * variants.length) % variants.length;\n      const variant = variants[variantIndex] ?? \"primary\";\n      const rotationDeg =\n        variant === \"primary\" ? 0 : variant === \"secondary\" ? 120 : 240;\n\n      const strokeOpacity =\n        rndIn(rng, opacity.stroke[0], opacity.stroke[1]) * band.strokeScale;\n      const fillOpacity =\n        rndIn(rng, opacity.fill[0], opacity.fill[1]) * band.fillScale;\n\n      result.push({\n        id: `${band.z}-${i}-${Math.floor(rng() * 1e9)}`,\n        xVw,\n        yVh,\n        size,\n        rotationDeg,\n        variant,\n        parallax,\n        zIndex: band.z,\n        strokeOpacity,\n        fillOpacity,\n      });\n    }\n  }\n\n  return result;\n}\n\n/** Brand glyph path and dimensions (lifted from the legacy GlyphField.astro) */\nconst GLYPH_PATH_D =\n  \"M0.55,10.626L18.002,0.55L35.456,10.627L35.472,30.771L24.893,36.879L29.541,39.562C29.543,39.564 29.546,39.565 29.548,39.567L30.716,40.241L23.83,44.202L14.575,38.873L0.55,30.778L0.55,10.626Z\";\nconst GLYPH_W = 37;\nconst GLYPH_H = 45;\n\n/** Color helpers (align with GlyphField variant colors) */\nfunction getStrokeColor(\n  variant: \"primary\" | \"secondary\" | \"tertiary\",\n  grayscale = false,\n): string {\n  if (grayscale) {\n    switch (variant) {\n      case \"primary\":\n        return \"#d4d4d4\";\n      case \"secondary\":\n        return \"#bdbdbd\";\n      case \"tertiary\":\n        return \"#a3a3a3\";\n    }\n  }\n  switch (variant) {\n    case \"primary\":\n      return \"#EF6129\"; // red-orange\n    case \"secondary\":\n      return \"#FF9E00\"; // yellow-orange\n    case \"tertiary\":\n      return \"#50C4B6\"; // teal\n  }\n}\n\nfunction getFillColor(\n  variant: \"primary\" | \"secondary\" | \"tertiary\",\n  grayscale = false,\n): string {\n  if (grayscale) {\n    switch (variant) {\n      case \"primary\":\n        return \"#d4d4d4\";\n      case \"secondary\":\n        return \"#bdbdbd\";\n      case \"tertiary\":\n        return \"#a3a3a3\";\n    }\n  }\n  switch (variant) {\n    case \"primary\":\n      return \"#EF6129\";\n    case \"secondary\":\n      return \"#FF9E00\";\n    case \"tertiary\":\n      return \"#50C4B6\";\n  }\n}\n\nconst MOBILE_UA_REGEX =\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone/i;\n\nfunction detectMobileDevice(): boolean {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n\n  const ua = navigator.userAgent || navigator.vendor || \"\";\n  if (MOBILE_UA_REGEX.test(ua)) {\n    return true;\n  }\n\n  if (\"maxTouchPoints\" in navigator && navigator.maxTouchPoints > 1) {\n    return true;\n  }\n\n  if (\n    typeof window !== \"undefined\" &&\n    typeof window.matchMedia === \"function\"\n  ) {\n    try {\n      if (window.matchMedia(\"(pointer: coarse)\").matches) {\n        return true;\n      }\n    } catch {\n      // ignore matchMedia failures\n    }\n  }\n\n  return false;\n}\n\nfunction Glyph({\n  spec,\n  virtualWidth,\n  virtualHeight,\n}: {\n  spec: GlyphSpec;\n  virtualWidth: number;\n  virtualHeight: number;\n}) {\n  // Near (parallax ~1) should be sharp; far (parallax small) slightly blurred.\n  // Depth-based blur: numeric per glyph (constant with respect to scroll)\n  const p = Math.max(0, Math.min(1, spec.parallax));\n  const nearBlur = 1; // px\n  const farBlur = 4; // px\n  const blurPx = farBlur - p * (farBlur - nearBlur);\n  const blurFilter = `blur(${blurPx}px)`;\n\n  const stroke = getStrokeColor(spec.variant);\n  const fill = getFillColor(spec.variant);\n\n  // Scale based on desired pixel size vs intrinsic glyph height\n  const s = spec.size / GLYPH_H;\n  const MAX_BLUR = 16;\n  const margin = MAX_BLUR;\n  const paddedSize = spec.size + margin * 2;\n\n  const baselineEdge = 100;\n  const extra = Math.max(0, virtualWidth / 16);\n  const adjustedVw = spec.xVw >= baselineEdge ? spec.xVw + extra : spec.xVw;\n  const leftPx = (adjustedVw / 100) * virtualWidth - margin;\n  const topPx = (spec.yVh / 100) * virtualHeight - margin;\n\n  return (\n    <div style={{ filter: blurFilter, WebkitFilter: blurFilter }}>\n      <svg\n        width={paddedSize}\n        height={paddedSize}\n        viewBox={`${-GLYPH_W / 2} ${-GLYPH_H / 2} ${GLYPH_W} ${GLYPH_H}`}\n        style={{\n          position: \"absolute\",\n          left: `${leftPx}px`,\n          top: `${topPx}px`,\n          zIndex: spec.zIndex,\n          opacity: 1,\n          pointerEvents: \"none\",\n          overflow: \"visible\",\n          willChange: \"transform, filter\",\n        }}\n        aria-hidden=\"true\"\n      >\n        <g\n          transform={`rotate(${spec.rotationDeg})`}\n          style={{ filter: blurFilter, WebkitFilter: blurFilter }}\n        >\n          <path\n            d={GLYPH_PATH_D}\n            fill={fill}\n            fillOpacity={spec.fillOpacity}\n            stroke={stroke}\n            strokeOpacity={spec.strokeOpacity}\n            strokeWidth={1}\n            vectorEffect=\"non-scaling-stroke\"\n            transform={`translate(${(-GLYPH_W / 2) * s}, ${(-GLYPH_H / 2) * s}) scale(${s})`}\n          />\n        </g>\n      </svg>\n    </div>\n  );\n}\n\nexport default function ParallaxHexBackground({\n  count = 48,\n  seed,\n  verticalSpanVh = 220,\n  horizontalRangeVw = { min: -10, max: 110 },\n  palette = [\"#50C4B6\", \"#FF9E00\", \"#EF6129\"], // teal, yellow-orange, red-orange\n  opacity = { stroke: [0.22, 0.55], fill: [0.05, 0.18] },\n  className = \"\",\n}: ParallaxHexBackgroundProps) {\n  const MIN_VIRTUAL_WIDTH = 768;\n  const MIN_VIRTUAL_HEIGHT = 960;\n  const VIEWPORT_THRESHOLD = 24;\n  const getInitialViewport = () => {\n    if (typeof window === \"undefined\") {\n      return { width: MIN_VIRTUAL_WIDTH, height: MIN_VIRTUAL_HEIGHT };\n    }\n    return {\n      width: window.innerWidth,\n      height: Math.max(MIN_VIRTUAL_HEIGHT, window.innerHeight),\n    };\n  };\n  const [viewport, setViewport] = useState(getInitialViewport);\n  const [isMobileDevice, setIsMobileDevice] = useState(() =>\n    detectMobileDevice(),\n  );\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n    let frame: number | null = null;\n    const handleResize = () => {\n      if (frame) cancelAnimationFrame(frame);\n      frame = requestAnimationFrame(() => {\n        const nextWidth = window.innerWidth;\n        const nextHeight = Math.max(MIN_VIRTUAL_HEIGHT, window.innerHeight);\n        setViewport((prev) => {\n          if (\n            Math.abs(prev.width - nextWidth) < VIEWPORT_THRESHOLD &&\n            Math.abs(prev.height - nextHeight) < VIEWPORT_THRESHOLD\n          ) {\n            return prev;\n          }\n          return { width: nextWidth, height: nextHeight };\n        });\n      });\n    };\n    window.addEventListener(\"resize\", handleResize, { passive: true });\n    window.visualViewport?.addEventListener(\"resize\", handleResize);\n    return () => {\n      if (frame) cancelAnimationFrame(frame);\n      window.removeEventListener(\"resize\", handleResize);\n      window.visualViewport?.removeEventListener(\"resize\", handleResize);\n    };\n  }, []);\n\n  useEffect(() => {\n    setIsMobileDevice(detectMobileDevice());\n  }, []);\n\n  const virtualWidth = Math.max(MIN_VIRTUAL_WIDTH, viewport.width);\n  const virtualHeight = Math.max(MIN_VIRTUAL_HEIGHT, viewport.height);\n  const isMobile = virtualWidth <= 768;\n  const effectiveCount = isMobile\n    ? Math.max(24, Math.round(count * 0.75))\n    : count;\n  const disableParallax = isMobileDevice;\n\n  const glyphs = useMemo(\n    () =>\n      generateGlyphs({\n        count: effectiveCount,\n        seed: seed ?? new Date().toISOString().slice(0, 10),\n        palette,\n        verticalSpanVh,\n        horizontalRangeVw,\n        opacity,\n      }).sort((a, b) => a.zIndex - b.zIndex), // ensure back-to-front rendering\n    [effectiveCount, seed, palette, verticalSpanVh, horizontalRangeVw, opacity],\n  );\n\n  const glyphBands = useMemo(() => {\n    const near: GlyphSpec[] = [];\n    const mid: GlyphSpec[] = [];\n    const far: GlyphSpec[] = [];\n    for (const glyph of glyphs) {\n      if (glyph.zIndex === 3) near.push(glyph);\n      else if (glyph.zIndex === 2) mid.push(glyph);\n      else far.push(glyph);\n    }\n    return { near, mid, far };\n  }, [glyphs]);\n\n  const nearParallax = 0.8;\n  const midParallax = 0.45;\n  const farParallax = 0.18;\n\n  // Subscribe to page scroll once and pass motion value to children\n  const { scrollY } = useScroll();\n  const smoothedScroll = useSpring(scrollY, {\n    stiffness: 250,\n    damping: 30,\n    mass: 0.2,\n  });\n  const staticScroll = useMotionValue(0);\n  const scrollSource = disableParallax\n    ? staticScroll\n    : isMobileDevice\n      ? smoothedScroll\n      : scrollY;\n  const nearY = useTransform(scrollSource, (v) => -v * nearParallax);\n  const midY = useTransform(scrollSource, (v) => -v * midParallax);\n  const farY = useTransform(scrollSource, (v) => -v * farParallax);\n\n  return (\n    <div\n      className={`pointer-events-none fixed inset-0 ${className}`}\n      aria-hidden=\"true\"\n    >\n      {[\n        { key: \"near\", mv: nearY, items: glyphBands.near },\n        { key: \"mid\", mv: midY, items: glyphBands.mid },\n        { key: \"far\", mv: farY, items: glyphBands.far },\n      ].map(({ key, mv, items }) =>\n        items.length ? (\n          <motion.div\n            key={key}\n            style={{\n              y: disableParallax ? 0 : mv,\n              position: \"absolute\",\n              inset: 0,\n              pointerEvents: \"none\",\n            }}\n            aria-hidden=\"true\"\n          >\n            {items.map((glyph) => (\n              <Glyph\n                key={glyph.id}\n                spec={glyph}\n                virtualWidth={virtualWidth}\n                virtualHeight={virtualHeight}\n              />\n            ))}\n          </motion.div>\n        ) : null,\n      )}\n    </div>\n  );\n}\n"],"names":["resizeHandlers","observer","getSize","borderBoxAxis","svgAxis","htmlAxis","target","borderBoxSize","isSVGElement","getWidth","getHeight","notifyTarget","handler","notifyAll","entries","createResizeObserver","resizeElement","elements","resolveElements","element","elementHandlers","windowCallbacks","windowResizeHandler","createWindowResizeHandler","info","callback","resizeWindow","resize","a","b","observeTimeline","update","timeline","prevProgress","onFrame","currentTime","progress","frame","cancelFrame","transform","args","useImmediate","argOffset","inputValue","inputRange","outputRange","options","interpolator","interpolate","attachSpring","value","source","initialValue","activeAnimation","latestValue","latestSetter","unit","stopAnimation","startAnimation","JSAnimation","asNumber","v","set","latest","parseValue","isMotionValue","removeSourceOnChange","removeValueOnDestroy","maxElapsed","createAxisInfo","createScrollInfo","keys","updateAxisInfo","axisName","time","axis","length","position","prev","prevTime","elapsed","velocityPerSecond","updateScrollInfo","calcInset","container","inset","current","isHTMLElement","svgBoundingBox","parentBoundingBox","x","y","svg","parent","namedEdges","resolveEdge","edge","delta","defaultOffset","resolveOffset","offset","containerLength","targetLength","targetInset","offsetDefinition","targetPoint","containerPoint","ScrollOffset","point","getTargetSize","resolveOffsets","lengthLabel","targetSize","containerSize","hasChanged","numOffsets","i","clamp","measure","node","createOnScrollHandler","onScroll","scrollListeners","resizeListeners","onScrollHandlers","getEventTarget","scrollInfo","noop","containerHandlers","containerHandler","measureAll","frameData","listener","currentHandlers","scrollListener","timelineCache","scrollTimelineFallback","cancel","getTimeline","containerCache","targetKey","targetCache","axisKey","supportsScrollTimeline","attachToAnimation","animation","valueAnimation","isOnScrollWithInfo","attachToFunction","scroll","optionsWithDefaults","createScrollMotionValues","motionValue","isRefPending","ref","useScroll","values","useConstant","scrollAnimation","useRef","needsStart","start","useCallback","_progress","useIsomorphicLayoutEffect","useEffect","invariant","useMotionValue","initial","isStatic","useContext","MotionConfigContext","setLatest","useState","useCombineMotionValues","combineValues","updateValue","scheduleUpdate","subscriptions","unsubscribe","useComputed","compute","collectMotionValues","useTransform","input","inputRangeOrTransformer","transformer","useListTransform","numValues","useSpring","getFromSource","useInsertionEffect","createRng","seed","h","s","t","rndIn","rng","min","max","generateGlyphs","count","palette","verticalSpanVh","horizontalRangeVw","opacity","nearCount","midCount","farCount","result","bands","variants","band","u","size","parallax","xVw","yVh","variantIndex","variant","rotationDeg","strokeOpacity","fillOpacity","GLYPH_PATH_D","GLYPH_W","GLYPH_H","getStrokeColor","grayscale","getFillColor","MOBILE_UA_REGEX","detectMobileDevice","ua","Glyph","spec","virtualWidth","virtualHeight","p","nearBlur","farBlur","blurFilter","stroke","fill","margin","paddedSize","baselineEdge","extra","leftPx","topPx","jsx","ParallaxHexBackground","className","getInitialViewport","viewport","setViewport","isMobileDevice","setIsMobileDevice","handleResize","nextWidth","nextHeight","effectiveCount","disableParallax","glyphs","useMemo","glyphBands","near","mid","far","glyph","nearParallax","midParallax","farParallax","scrollY","smoothedScroll","staticScroll","scrollSource","nearY","midY","farY","key","mv","items","motion"],"mappings":"iSAGA,MAAMA,EAAiB,IAAI,QAC3B,IAAIC,EACJ,MAAMC,GAAU,CAACC,EAAeC,EAASC,IAAa,CAACC,EAAQC,IACvDA,GAAiBA,EAAc,CAAC,EACzBA,EAAc,CAAC,EAAGJ,EAAgB,MAAM,EAE1CK,GAAaF,CAAM,GAAK,YAAaA,EACnCA,EAAO,QAAO,EAAGF,CAAO,EAGxBE,EAAOD,CAAQ,EAGxBI,GAAyBP,GAAQ,SAAU,QAAS,aAAa,EACjEQ,GAA0BR,GAAQ,QAAS,SAAU,cAAc,EACzE,SAASS,GAAa,CAAE,OAAAL,EAAQ,cAAAC,GAAiB,CAC7CP,EAAe,IAAIM,CAAM,GAAG,QAASM,GAAY,CAC7CA,EAAQN,EAAQ,CACZ,IAAI,OAAQ,CACR,OAAOG,GAASH,EAAQC,CAAa,CACzC,EACA,IAAI,QAAS,CACT,OAAOG,GAAUJ,EAAQC,CAAa,CAC1C,CACZ,CAAS,CACL,CAAC,CACL,CACA,SAASM,GAAUC,EAAS,CACxBA,EAAQ,QAAQH,EAAY,CAChC,CACA,SAASI,IAAuB,CACxB,OAAO,eAAmB,MAE9Bd,EAAW,IAAI,eAAeY,EAAS,EAC3C,CACA,SAASG,GAAcV,EAAQM,EAAS,CAC/BX,GACDc,GAAoB,EACxB,MAAME,EAAWC,GAAgBZ,CAAM,EACvC,OAAAW,EAAS,QAASE,GAAY,CAC1B,IAAIC,EAAkBpB,EAAe,IAAImB,CAAO,EAC3CC,IACDA,EAAkB,IAAI,IACtBpB,EAAe,IAAImB,EAASC,CAAe,GAE/CA,EAAgB,IAAIR,CAAO,EAC3BX,GAAU,QAAQkB,CAAO,CAC7B,CAAC,EACM,IAAM,CACTF,EAAS,QAASE,GAAY,CAC1B,MAAMC,EAAkBpB,EAAe,IAAImB,CAAO,EAClDC,GAAiB,OAAOR,CAAO,EAC1BQ,GAAiB,MAClBnB,GAAU,UAAUkB,CAAO,CAEnC,CAAC,CACL,CACJ,CC5DA,MAAME,EAAkB,IAAI,IAC5B,IAAIC,EACJ,SAASC,IAA4B,CACjCD,EAAsB,IAAM,CACxB,MAAME,EAAO,CACT,IAAI,OAAQ,CACR,OAAO,OAAO,UAClB,EACA,IAAI,QAAS,CACT,OAAO,OAAO,WAClB,CACZ,EACQH,EAAgB,QAASI,GAAaA,EAASD,CAAI,CAAC,CACxD,EACA,OAAO,iBAAiB,SAAUF,CAAmB,CACzD,CACA,SAASI,GAAaD,EAAU,CAC5B,OAAAJ,EAAgB,IAAII,CAAQ,EACvBH,GACDC,GAAyB,EACtB,IAAM,CACTF,EAAgB,OAAOI,CAAQ,EAC3B,CAACJ,EAAgB,MACjB,OAAOC,GAAwB,aAC/B,OAAO,oBAAoB,SAAUA,CAAmB,EACxDA,EAAsB,OAE9B,CACJ,CCzBA,SAASK,GAAOC,EAAGC,EAAG,CAClB,OAAO,OAAOD,GAAM,WAAaF,GAAaE,CAAC,EAAIZ,GAAcY,EAAGC,CAAC,CACzE,CCHA,SAASC,GAAgBC,EAAQC,EAAU,CACvC,IAAIC,EACJ,MAAMC,EAAU,IAAM,CAClB,KAAM,CAAE,YAAAC,CAAW,EAAKH,EAElBI,GADaD,IAAgB,KAAO,EAAIA,EAAY,OAC5B,IAC1BF,IAAiBG,GACjBL,EAAOK,CAAQ,EAEnBH,EAAeG,CACnB,EACA,OAAAC,EAAM,UAAUH,EAAS,EAAI,EACtB,IAAMI,EAAYJ,CAAO,CACpC,CCbA,SAASK,MAAaC,EAAM,CACxB,MAAMC,EAAe,CAAC,MAAM,QAAQD,EAAK,CAAC,CAAC,EACrCE,EAAYD,EAAe,EAAI,GAC/BE,EAAaH,EAAK,EAAIE,CAAS,EAC/BE,EAAaJ,EAAK,EAAIE,CAAS,EAC/BG,EAAcL,EAAK,EAAIE,CAAS,EAChCI,EAAUN,EAAK,EAAIE,CAAS,EAC5BK,EAAeC,GAAYJ,EAAYC,EAAaC,CAAO,EACjE,OAAOL,EAAeM,EAAaJ,CAAU,EAAII,CACrD,CCcA,SAASE,GAAaC,EAAOC,EAAQL,EAAS,CAC1C,MAAMM,EAAeF,EAAM,IAAG,EAC9B,IAAIG,EAAkB,KAClBC,EAAcF,EACdG,EACJ,MAAMC,EAAO,OAAOJ,GAAiB,SAC/BA,EAAa,QAAQ,UAAW,EAAE,EAClC,OACAK,EAAgB,IAAM,CACpBJ,IACAA,EAAgB,KAAI,EACpBA,EAAkB,KAE1B,EACMK,EAAiB,IAAM,CACzBD,EAAa,EACbJ,EAAkB,IAAIM,GAAY,CAC9B,UAAW,CAACC,GAASV,EAAM,IAAG,CAAE,EAAGU,GAASN,CAAW,CAAC,EACxD,SAAUJ,EAAM,YAAW,EAC3B,KAAM,SACN,UAAW,KACX,UAAW,IACX,GAAGJ,EACH,SAAUS,CACtB,CAAS,CACL,EAMA,GALAL,EAAM,OAAO,CAACW,EAAGC,IAAQ,CACrBR,EAAcO,EACdN,EAAgBQ,GAAWD,EAAIE,EAAWD,EAAQP,CAAI,CAAC,EACvDnB,EAAM,WAAWqB,CAAc,CACnC,EAAGD,CAAa,EACZQ,GAAcd,CAAM,EAAG,CACvB,MAAMe,EAAuBf,EAAO,GAAG,SAAWU,GAAMX,EAAM,IAAIc,EAAWH,EAAGL,CAAI,CAAC,CAAC,EAChFW,EAAuBjB,EAAM,GAAG,UAAWgB,CAAoB,EACrE,MAAO,IAAM,CACTA,EAAoB,EACpBC,EAAoB,CACxB,CACJ,CACA,OAAOV,CACX,CACA,SAASO,EAAWH,EAAGL,EAAM,CACzB,OAAOA,EAAOK,EAAIL,EAAOK,CAC7B,CACA,SAASD,GAASC,EAAG,CACjB,OAAO,OAAOA,GAAM,SAAWA,EAAI,WAAWA,CAAC,CACnD,CClEA,MAAMO,GAAa,GACbC,GAAiB,KAAO,CAC1B,QAAS,EACT,OAAQ,CAAA,EACR,SAAU,EACV,aAAc,EACd,aAAc,EACd,aAAc,EACd,gBAAiB,EACjB,SAAU,CACd,GACMC,GAAmB,KAAO,CAC5B,KAAM,EACN,EAAGD,GAAc,EACjB,EAAGA,GAAc,CACrB,GACME,GAAO,CACT,EAAG,CACC,OAAQ,QACR,SAAU,MAClB,EACI,EAAG,CACC,OAAQ,SACR,SAAU,KAClB,CACA,EACA,SAASC,GAAerD,EAASsD,EAAUjD,EAAMkD,EAAM,CACnD,MAAMC,EAAOnD,EAAKiD,CAAQ,EACpB,CAAE,OAAAG,EAAQ,SAAAC,GAAaN,GAAKE,CAAQ,EACpCK,EAAOH,EAAK,QACZI,EAAWvD,EAAK,KACtBmD,EAAK,QAAUxD,EAAQ,SAAS0D,CAAQ,EAAE,EAC1CF,EAAK,aAAexD,EAAQ,SAASyD,CAAM,EAAE,EAAIzD,EAAQ,SAASyD,CAAM,EAAE,EAC1ED,EAAK,OAAO,OAAS,EACrBA,EAAK,OAAO,CAAC,EAAI,EACjBA,EAAK,OAAO,CAAC,EAAIA,EAAK,aACtBA,EAAK,SAAWvC,GAAS,EAAGuC,EAAK,aAAcA,EAAK,OAAO,EAC3D,MAAMK,EAAUN,EAAOK,EACvBJ,EAAK,SACDK,EAAUZ,GACJ,EACAa,GAAkBN,EAAK,QAAUG,EAAME,CAAO,CAC5D,CACA,SAASE,GAAiB/D,EAASK,EAAMkD,EAAM,CAC3CF,GAAerD,EAAS,IAAKK,EAAMkD,CAAI,EACvCF,GAAerD,EAAS,IAAKK,EAAMkD,CAAI,EACvClD,EAAK,KAAOkD,CAChB,CClDA,SAASS,GAAUhE,EAASiE,EAAW,CACnC,MAAMC,EAAQ,CAAE,EAAG,EAAG,EAAG,CAAC,EAC1B,IAAIC,EAAUnE,EACd,KAAOmE,GAAWA,IAAYF,GAC1B,GAAIG,GAAcD,CAAO,EACrBD,EAAM,GAAKC,EAAQ,WACnBD,EAAM,GAAKC,EAAQ,UACnBA,EAAUA,EAAQ,qBAEbA,EAAQ,UAAY,MAAO,CAQhC,MAAME,EAAiBF,EAAQ,sBAAqB,EACpDA,EAAUA,EAAQ,cAClB,MAAMG,EAAoBH,EAAQ,sBAAqB,EACvDD,EAAM,GAAKG,EAAe,KAAOC,EAAkB,KACnDJ,EAAM,GAAKG,EAAe,IAAMC,EAAkB,GACtD,SACSH,aAAmB,mBAAoB,CAC5C,KAAM,CAAE,EAAAI,EAAG,EAAAC,GAAML,EAAQ,QAAO,EAChCD,EAAM,GAAKK,EACXL,EAAM,GAAKM,EACX,IAAIC,EAAM,KACNC,EAASP,EAAQ,WACrB,KAAO,CAACM,GACAC,EAAO,UAAY,QACnBD,EAAMC,GAEVA,EAASP,EAAQ,WAErBA,EAAUM,CACd,KAEI,OAGR,OAAOP,CACX,CC5CA,MAAMS,EAAa,CACf,MAAO,EACP,OAAQ,GACR,IAAK,CACT,EACA,SAASC,GAAYC,EAAMpB,EAAQS,EAAQ,EAAG,CAC1C,IAAIY,EAAQ,EAWZ,GANID,KAAQF,IACRE,EAAOF,EAAWE,CAAI,GAKtB,OAAOA,GAAS,SAAU,CAC1B,MAAMpC,EAAW,WAAWoC,CAAI,EAC5BA,EAAK,SAAS,IAAI,EAClBC,EAAQrC,EAEHoC,EAAK,SAAS,GAAG,EACtBA,EAAOpC,EAAW,IAEboC,EAAK,SAAS,IAAI,EACvBC,EAASrC,EAAW,IAAO,SAAS,gBAAgB,YAE/CoC,EAAK,SAAS,IAAI,EACvBC,EAASrC,EAAW,IAAO,SAAS,gBAAgB,aAGpDoC,EAAOpC,CAEf,CAIA,OAAI,OAAOoC,GAAS,WAChBC,EAAQrB,EAASoB,GAEdX,EAAQY,CACnB,CCxCA,MAAMC,GAAgB,CAAC,EAAG,CAAC,EAC3B,SAASC,GAAcC,EAAQC,EAAiBC,EAAcC,EAAa,CACvE,IAAIC,EAAmB,MAAM,QAAQJ,CAAM,EAAIA,EAASF,GACpDO,EAAc,EACdC,EAAiB,EACrB,OAAI,OAAON,GAAW,SAMlBI,EAAmB,CAACJ,EAAQA,CAAM,EAE7B,OAAOA,GAAW,WACvBA,EAASA,EAAO,KAAI,EAChBA,EAAO,SAAS,GAAG,EACnBI,EAAmBJ,EAAO,MAAM,GAAG,EAQnCI,EAAmB,CAACJ,EAAQN,EAAWM,CAAM,EAAIA,EAAS,GAAG,GAGrEK,EAAcV,GAAYS,EAAiB,CAAC,EAAGF,EAAcC,CAAW,EACxEG,EAAiBX,GAAYS,EAAiB,CAAC,EAAGH,CAAe,EAC1DI,EAAcC,CACzB,CChCA,MAAMC,GAAe,CAajB,IAAK,CACD,CAAC,EAAG,CAAC,EACL,CAAC,EAAG,CAAC,CACb,CACA,ECXMC,GAAQ,CAAE,EAAG,EAAG,EAAG,CAAC,EAC1B,SAASC,GAAcvG,EAAQ,CAC3B,MAAO,YAAaA,GAAUA,EAAO,UAAY,MAC3CA,EAAO,QAAO,EACd,CAAE,MAAOA,EAAO,YAAa,OAAQA,EAAO,YAAY,CAClE,CACA,SAASwG,GAAe1B,EAAW5D,EAAMsB,EAAS,CAC9C,KAAM,CAAE,OAAQ0D,EAAmBG,GAAa,GAAG,EAAK7D,EAClD,CAAE,OAAAxC,EAAS8E,EAAW,KAAAT,EAAO,GAAG,EAAK7B,EACrCiE,EAAcpC,IAAS,IAAM,SAAW,QACxCU,EAAQ/E,IAAW8E,EAAYD,GAAU7E,EAAQ8E,CAAS,EAAIwB,GAM9DI,EAAa1G,IAAW8E,EACxB,CAAE,MAAOA,EAAU,YAAa,OAAQA,EAAU,YAAY,EAC9DyB,GAAcvG,CAAM,EACpB2G,EAAgB,CAClB,MAAO7B,EAAU,YACjB,OAAQA,EAAU,YAC1B,EAKI5D,EAAKmD,CAAI,EAAE,OAAO,OAAS,EAK3B,IAAIuC,EAAa,CAAC1F,EAAKmD,CAAI,EAAE,YAC7B,MAAMwC,EAAaX,EAAiB,OACpC,QAASY,EAAI,EAAGA,EAAID,EAAYC,IAAK,CACjC,MAAMhB,EAASD,GAAcK,EAAiBY,CAAC,EAAGH,EAAcF,CAAW,EAAGC,EAAWD,CAAW,EAAG1B,EAAMV,CAAI,CAAC,EAC9G,CAACuC,GAAcd,IAAW5E,EAAKmD,CAAI,EAAE,oBAAoByC,CAAC,IAC1DF,EAAa,IAEjB1F,EAAKmD,CAAI,EAAE,OAAOyC,CAAC,EAAIhB,CAC3B,CAKIc,IACA1F,EAAKmD,CAAI,EAAE,YAAc3B,GAAYxB,EAAKmD,CAAI,EAAE,OAAQuB,GAAcM,CAAgB,EAAG,CAAE,MAAO,EAAK,CAAE,EACzGhF,EAAKmD,CAAI,EAAE,oBAAsB,CAAC,GAAGnD,EAAKmD,CAAI,EAAE,MAAM,GAE1DnD,EAAKmD,CAAI,EAAE,SAAW0C,GAAM,EAAG,EAAG7F,EAAKmD,CAAI,EAAE,YAAYnD,EAAKmD,CAAI,EAAE,OAAO,CAAC,CAChF,CCpDA,SAAS2C,GAAQlC,EAAW9E,EAAS8E,EAAW5D,EAAM,CAMlD,GAFAA,EAAK,EAAE,aAAe,EACtBA,EAAK,EAAE,aAAe,EAClBlB,IAAW8E,EAAW,CACtB,IAAImC,EAAOjH,EACX,KAAOiH,GAAQA,IAASnC,GACpB5D,EAAK,EAAE,cAAgB+F,EAAK,WAC5B/F,EAAK,EAAE,cAAgB+F,EAAK,UAC5BA,EAAOA,EAAK,YAEpB,CACA/F,EAAK,EAAE,aACHlB,IAAW8E,EAAY9E,EAAO,YAAcA,EAAO,YACvDkB,EAAK,EAAE,aACHlB,IAAW8E,EAAY9E,EAAO,aAAeA,EAAO,aACxDkB,EAAK,EAAE,gBAAkB4D,EAAU,YACnC5D,EAAK,EAAE,gBAAkB4D,EAAU,YAUvC,CACA,SAASoC,GAAsBrG,EAASsG,EAAUjG,EAAMsB,EAAU,CAAA,EAAI,CAClE,MAAO,CACH,QAAU4B,GAAS,CACf4C,GAAQnG,EAAS2B,EAAQ,OAAQtB,CAAI,EACrC0D,GAAiB/D,EAASK,EAAMkD,CAAI,GAChC5B,EAAQ,QAAUA,EAAQ,SAC1BgE,GAAe3F,EAASK,EAAMsB,CAAO,CAE7C,EACA,OAAQ,IAAM2E,EAASjG,CAAI,CAAA,CAEnC,CCxCA,MAAMkG,EAAkB,IAAI,QACtBC,GAAkB,IAAI,QACtBC,EAAmB,IAAI,QACvBC,GAAkB1G,GAAYA,IAAY,SAAS,iBAAmB,OAASA,EACrF,SAAS2G,GAAWL,EAAU,CAAE,UAAArC,EAAY,SAAS,iBAAkB,GAAGtC,CAAO,EAAK,GAAI,CACtF,GAAI,CAACsC,EACD,OAAO2C,GACX,IAAIC,EAAoBJ,EAAiB,IAAIxC,CAAS,EAKjD4C,IACDA,EAAoB,IAAI,IACxBJ,EAAiB,IAAIxC,EAAW4C,CAAiB,GAKrD,MAAMxG,EAAO8C,GAAgB,EACvB2D,EAAmBT,GAAsBpC,EAAWqC,EAAUjG,EAAMsB,CAAO,EAMjF,GALAkF,EAAkB,IAAIC,CAAgB,EAKlC,CAACP,EAAgB,IAAItC,CAAS,EAAG,CACjC,MAAM8C,EAAa,IAAM,CACrB,UAAWtH,KAAWoH,EAClBpH,EAAQ,QAAQuH,GAAU,SAAS,EAEvC9F,EAAM,UAAUxB,CAAS,CAC7B,EACMA,EAAY,IAAM,CACpB,UAAWD,KAAWoH,EAClBpH,EAAQ,OAAM,CAEtB,EACMwH,EAAW,IAAM/F,EAAM,KAAK6F,CAAU,EAC5CR,EAAgB,IAAItC,EAAWgD,CAAQ,EACvC,MAAM9H,EAASuH,GAAezC,CAAS,EACvC,OAAO,iBAAiB,SAAUgD,EAAU,CAAE,QAAS,GAAM,EACzDhD,IAAc,SAAS,iBACvBuC,GAAgB,IAAIvC,EAAWzD,GAAOyD,EAAWgD,CAAQ,CAAC,EAE9D9H,EAAO,iBAAiB,SAAU8H,EAAU,CAAE,QAAS,GAAM,EAC7DA,EAAQ,CACZ,CACA,MAAMA,EAAWV,EAAgB,IAAItC,CAAS,EAC9C,OAAA/C,EAAM,KAAK+F,EAAU,GAAO,EAAI,EACzB,IAAM,CACT9F,EAAY8F,CAAQ,EAIpB,MAAMC,EAAkBT,EAAiB,IAAIxC,CAAS,EAItD,GAHI,CAACiD,IAELA,EAAgB,OAAOJ,CAAgB,EACnCI,EAAgB,MAChB,OAIJ,MAAMC,EAAiBZ,EAAgB,IAAItC,CAAS,EACpDsC,EAAgB,OAAOtC,CAAS,EAC5BkD,IACAT,GAAezC,CAAS,EAAE,oBAAoB,SAAUkD,CAAc,EACtEX,GAAgB,IAAIvC,CAAS,IAAC,EAC9B,OAAO,oBAAoB,SAAUkD,CAAc,EAE3D,CACJ,CC1EA,MAAMC,GAAgB,IAAI,IAC1B,SAASC,GAAuB1F,EAAS,CACrC,MAAMX,EAAc,CAAE,MAAO,CAAC,EACxBsG,EAASX,GAAYtG,GAAS,CAChCW,EAAY,MAAQX,EAAKsB,EAAQ,IAAI,EAAE,SAAW,GACtD,EAAGA,CAAO,EACV,MAAO,CAAE,YAAAX,EAAa,OAAAsG,CAAM,CAChC,CACA,SAASC,GAAY,CAAE,OAAAvF,EAAQ,UAAAiC,EAAW,GAAGtC,CAAO,EAAI,CACpD,KAAM,CAAE,KAAA6B,CAAI,EAAK7B,EACbK,IACAiC,EAAYjC,GAChB,MAAMwF,EAAiBJ,GAAc,IAAInD,CAAS,GAAK,IAAI,IAC3DmD,GAAc,IAAInD,EAAWuD,CAAc,EAC3C,MAAMC,EAAY9F,EAAQ,QAAU,OAC9B+F,EAAcF,EAAe,IAAIC,CAAS,GAAK,CAAA,EAC/CE,EAAUnE,GAAQ7B,EAAQ,QAAU,CAAA,GAAI,KAAK,GAAG,EACtD,OAAK+F,EAAYC,CAAO,IACpBD,EAAYC,CAAO,EACf,CAAChG,EAAQ,QAAUiG,GAAsB,EACnC,IAAI,eAAe,CAAE,OAAQ3D,EAAW,KAAAT,CAAI,CAAE,EAC9C6D,GAAuB,CAAE,UAAApD,EAAW,GAAGtC,EAAS,GAEvD+F,EAAYC,CAAO,CAC9B,CCxBA,SAASE,GAAkBC,EAAWnG,EAAS,CAC3C,MAAMd,EAAW0G,GAAY5F,CAAO,EACpC,OAAOmG,EAAU,eAAe,CAC5B,SAAUnG,EAAQ,OAAS,OAAYd,EACvC,QAAUkH,IACNA,EAAe,MAAK,EACbpH,GAAiBM,GAAa,CACjC8G,EAAe,KACXA,EAAe,kBAAoB9G,CAC3C,EAAGJ,CAAQ,EAEvB,CAAK,CACL,CCPA,SAASmH,GAAmB1B,EAAU,CAClC,OAAOA,EAAS,SAAW,CAC/B,CACA,SAAS2B,GAAiB3B,EAAU3E,EAAS,CACzC,OAAIqG,GAAmB1B,CAAQ,EACpBK,GAAYtG,GAAS,CACxBiG,EAASjG,EAAKsB,EAAQ,IAAI,EAAE,SAAUtB,CAAI,CAC9C,EAAGsB,CAAO,EAGHhB,GAAgB2F,EAAUiB,GAAY5F,CAAO,CAAC,CAE7D,CChBA,SAASuG,GAAO5B,EAAU,CAAE,KAAA9C,EAAO,IAAK,UAAAS,EAAY,SAAS,iBAAkB,GAAGtC,CAAO,EAAK,GAAI,CAC9F,GAAI,CAACsC,EACD,OAAO2C,GACX,MAAMuB,EAAsB,CAAE,KAAA3E,EAAM,UAAAS,EAAW,GAAGtC,CAAO,EACzD,OAAO,OAAO2E,GAAa,WACrB2B,GAAiB3B,EAAU6B,CAAmB,EAC9CN,GAAkBvB,EAAU6B,CAAmB,CACzD,CCHA,MAAMC,GAA2B,KAAO,CACpC,QAASC,EAAY,CAAC,EACtB,QAASA,EAAY,CAAC,EACtB,gBAAiBA,EAAY,CAAC,EAC9B,gBAAiBA,EAAY,CAAC,CAClC,GACMC,EAAgBC,GACbA,EAEE,CAACA,EAAI,QADD,GAGf,SAASC,GAAU,CAAE,UAAAvE,EAAW,OAAA9E,EAAQ,GAAGwC,CAAO,EAAK,CAAA,EAAI,CACvD,MAAM8G,EAASC,EAAYN,EAAwB,EAC7CO,EAAkBC,EAAAA,OAAO,IAAI,EAC7BC,EAAaD,EAAAA,OAAO,EAAK,EACzBE,EAAQC,EAAAA,YAAY,KACtBJ,EAAgB,QAAUT,GAAO,CAACc,EAAW,CAAE,EAAAzE,EAAG,EAAAC,KAAS,CACvDiE,EAAO,QAAQ,IAAIlE,EAAE,OAAO,EAC5BkE,EAAO,gBAAgB,IAAIlE,EAAE,QAAQ,EACrCkE,EAAO,QAAQ,IAAIjE,EAAE,OAAO,EAC5BiE,EAAO,gBAAgB,IAAIjE,EAAE,QAAQ,CACzC,EAAG,CACC,GAAG7C,EACH,UAAWsC,GAAW,SAAW,OACjC,OAAQ9E,GAAQ,SAAW,MACvC,CAAS,EACM,IAAM,CACTwJ,EAAgB,UAAO,CAC3B,GACD,CAAC1E,EAAW9E,EAAQ,KAAK,UAAUwC,EAAQ,MAAM,CAAC,CAAC,EACtD,OAAAsH,GAA0B,IAAM,CAE5B,GADAJ,EAAW,QAAU,GACjBP,EAAarE,CAAS,GAAKqE,EAAanJ,CAAM,EAAG,CACjD0J,EAAW,QAAU,GACrB,MACJ,KAEI,QAAOC,EAAK,CAEpB,EAAG,CAACA,CAAK,CAAC,EACVI,EAAAA,UAAU,IAAM,CACZ,GAAIL,EAAW,QACX,OAAAM,EAAU,CAACb,EAAarE,CAAS,CAAgE,EACjGkF,EAAU,CAACb,EAAanJ,CAAM,CAA6D,EACpF2J,EAAK,CAKpB,EAAG,CAACA,CAAK,CAAC,EACHL,CACX,CCpCA,SAASW,EAAeC,EAAS,CAC7B,MAAMtH,EAAQ2G,EAAY,IAAML,EAAYgB,CAAO,CAAC,EAM9C,CAAE,SAAAC,CAAQ,EAAKC,EAAAA,WAAWC,EAAmB,EACnD,GAAIF,EAAU,CACV,KAAM,EAAGG,CAAS,EAAIC,EAAAA,SAASL,CAAO,EACtCH,EAAAA,UAAU,IAAMnH,EAAM,GAAG,SAAU0H,CAAS,EAAG,EAAE,CACrD,CACA,OAAO1H,CACX,CC/BA,SAAS4H,GAAuBlB,EAAQmB,EAAe,CAInD,MAAM7H,EAAQqH,EAAeQ,GAAe,EAOtCC,EAAc,IAAM9H,EAAM,IAAI6H,EAAa,CAAE,EAKnD,OAAAC,EAAW,EAKXZ,GAA0B,IAAM,CAC5B,MAAMa,EAAiB,IAAM5I,EAAM,UAAU2I,EAAa,GAAO,EAAI,EAC/DE,EAAgBtB,EAAO,IAAK/F,GAAMA,EAAE,GAAG,SAAUoH,CAAc,CAAC,EACtE,MAAO,IAAM,CACTC,EAAc,QAASC,GAAgBA,EAAW,CAAE,EACpD7I,EAAY0I,CAAW,CAC3B,CACJ,CAAC,EACM9H,CACX,CC/BA,SAASkI,GAAYC,EAAS,CAK1BC,EAAoB,QAAU,CAAA,EAC9BD,EAAO,EACP,MAAMnI,EAAQ4H,GAAuBQ,EAAoB,QAASD,CAAO,EAIzE,OAAAC,EAAoB,QAAU,OACvBpI,CACX,CCXA,SAASqI,EAAaC,EAAOC,EAAyB5I,EAAaC,EAAS,CACxE,GAAI,OAAO0I,GAAU,WACjB,OAAOJ,GAAYI,CAAK,EAE5B,MAAME,EAAc,OAAOD,GAA4B,WACjDA,EACAlJ,GAAUkJ,EAAyB5I,EAAaC,CAAO,EAC7D,OAAO,MAAM,QAAQ0I,CAAK,EACpBG,GAAiBH,EAAOE,CAAW,EACnCC,GAAiB,CAACH,CAAK,EAAG,CAAC,CAACzH,CAAM,IAAM2H,EAAY3H,CAAM,CAAC,CACrE,CACA,SAAS4H,GAAiB/B,EAAQ8B,EAAa,CAC3C,MAAM3H,EAAS8F,EAAY,IAAM,EAAE,EACnC,OAAOiB,GAAuBlB,EAAQ,IAAM,CACxC7F,EAAO,OAAS,EAChB,MAAM6H,EAAYhC,EAAO,OACzB,QAASxC,EAAI,EAAGA,EAAIwE,EAAWxE,IAC3BrD,EAAOqD,CAAC,EAAIwC,EAAOxC,CAAC,EAAE,IAAG,EAE7B,OAAOsE,EAAY3H,CAAM,CAC7B,CAAC,CACL,CCpBA,SAAS8H,GAAU1I,EAAQL,EAAU,GAAI,CACrC,KAAM,CAAE,SAAA2H,CAAQ,EAAKC,EAAAA,WAAWC,EAAmB,EAC7CmB,EAAgB,IAAO7H,GAAcd,CAAM,EAAIA,EAAO,IAAG,EAAKA,EAEpE,GAAIsH,EACA,OAAOc,EAAaO,CAAa,EAErC,MAAM5I,EAAQqH,EAAeuB,GAAe,EAC5CC,OAAAA,EAAAA,mBAAmB,IACR9I,GAAaC,EAAOC,EAAQL,CAAO,EAC3C,CAACI,EAAO,KAAK,UAAUJ,CAAO,CAAC,CAAC,EAC5BI,CACX,CC+DA,SAAS8I,GAAUC,EAAiD,CAClE,IAAIC,EAAI,WACR,MAAMC,EAAI,OAAOF,GAAQ,IAAI,OAAO,cAAc,MAAM,EAAG,EAAE,CAAC,EAC9D,QAAS7E,EAAI,EAAGA,EAAI+E,EAAE,OAAQ/E,IAC5B8E,GAAKC,EAAE,WAAW/E,CAAC,EACnB8E,EAAI,KAAK,KAAKA,EAAG,QAAQ,EAE3B,IAAItK,GAAKsK,EAAI,cAAgB,EAC7B,OAAO,UAAsB,CAC3BtK,GAAK,EACLA,EAAKA,EAAI,WAAc,EACvB,IAAIwK,EAAI,KAAK,KAAKxK,EAAKA,IAAM,GAAK,EAAIA,CAAC,EACvC,OAAAwK,EAAKA,EAAI,KAAK,KAAKA,EAAKA,IAAM,EAAI,GAAKA,CAAC,EAAKA,IACpCA,EAAKA,IAAM,MAAS,GAAK,UACpC,CACF,CAGA,SAASC,EAAMC,EAAmBC,EAAaC,EAAa,CAC1D,OAAOD,EAAMD,KAASE,EAAMD,EAC9B,CAIA,SAASE,GAAe,CACtB,MAAAC,EACA,KAAAT,EACA,QAAAU,EACA,eAAAC,EACA,kBAAAC,EACA,QAAAC,CACF,EAUgB,CACd,MAAMR,EAAMN,GAAUC,CAAI,EAGpBc,EAAY,KAAK,MAAML,EAAQ,GAAI,EACnCM,EAAW,KAAK,MAAMN,EAAQ,GAAI,EAClCO,EAAW,KAAK,IAAI,EAAGP,EAAQK,EAAYC,CAAQ,EAEnDE,EAAsB,CAAA,EAEtBC,EAOD,CAEH,CACE,EAAGJ,EACH,OAAQ,CAAC,GAAI,EAAE,EACf,SAAU,CAAC,IAAM,CAAG,EACpB,EAAG,EACH,YAAa,EACb,UAAW,CAAA,EAGb,CACE,EAAGC,EACH,OAAQ,CAAC,GAAI,EAAE,EACf,SAAU,CAAC,IAAM,EAAG,EACpB,EAAG,EACH,YAAa,GACb,UAAW,EAAA,EAGb,CACE,EAAGC,EACH,OAAQ,CAAC,GAAI,EAAE,EACf,SAAU,CAAC,IAAM,EAAG,EACpB,EAAG,EACH,YAAa,GACb,UAAW,EAAA,CACb,EAGIG,EAAwD,CAC5D,UACA,YACA,UAAA,EAGF,UAAWC,KAAQF,EACjB,QAAS/F,EAAI,EAAGA,EAAIiG,EAAK,EAAGjG,IAAK,CAC/B,MAAMkG,EAAIhB,EAAA,EACJF,EAAIiB,EAAK,IAAM,EAAI,KAAK,KAAKC,CAAC,EAAID,EAAK,IAAM,EAAIC,EAAIA,EAAIA,EACzDC,EAAOF,EAAK,OAAO,CAAC,GAAKA,EAAK,OAAO,CAAC,EAAIA,EAAK,OAAO,CAAC,GAAKjB,EAC5DoB,EAAWnB,EAAMC,EAAKe,EAAK,SAAS,CAAC,EAAGA,EAAK,SAAS,CAAC,CAAC,EACxDI,EAAMpB,EAAMC,EAAKO,EAAkB,IAAKA,EAAkB,GAAG,EAC7Da,EAAMrB,EAAMC,EAAK,CAACM,EAAiB,GAAK,IAAMA,EAAiB,EAAG,EAClEe,EACJ,KAAK,MAAMrB,EAAA,EAAQc,EAAS,MAAM,EAAIA,EAAS,OAC3CQ,EAAUR,EAASO,CAAY,GAAK,UACpCE,EACJD,IAAY,UAAY,EAAIA,IAAY,YAAc,IAAM,IAExDE,EACJzB,EAAMC,EAAKQ,EAAQ,OAAO,CAAC,EAAGA,EAAQ,OAAO,CAAC,CAAC,EAAIO,EAAK,YACpDU,EACJ1B,EAAMC,EAAKQ,EAAQ,KAAK,CAAC,EAAGA,EAAQ,KAAK,CAAC,CAAC,EAAIO,EAAK,UAEtDH,EAAO,KAAK,CACV,GAAI,GAAGG,EAAK,CAAC,IAAIjG,CAAC,IAAI,KAAK,MAAMkF,IAAQ,GAAG,CAAC,GAC7C,IAAAmB,EACA,IAAAC,EACA,KAAAH,EACA,YAAAM,EACA,QAAAD,EACA,SAAAJ,EACA,OAAQH,EAAK,EACb,cAAAS,EACA,YAAAC,CAAA,CACD,CACH,CAGF,OAAOb,CACT,CAGA,MAAMc,GACJ,+LACIC,EAAU,GACVC,EAAU,GAGhB,SAASC,GACPP,EACAQ,EAAY,GACJ,CACR,GAAIA,EACF,OAAQR,EAAA,CACN,IAAK,UACH,MAAO,UACT,IAAK,YACH,MAAO,UACT,IAAK,WACH,MAAO,SAAA,CAGb,OAAQA,EAAA,CACN,IAAK,UACH,MAAO,UACT,IAAK,YACH,MAAO,UACT,IAAK,WACH,MAAO,SAAA,CAEb,CAEA,SAASS,GACPT,EACAQ,EAAY,GACJ,CACR,GAAIA,EACF,OAAQR,EAAA,CACN,IAAK,UACH,MAAO,UACT,IAAK,YACH,MAAO,UACT,IAAK,WACH,MAAO,SAAA,CAGb,OAAQA,EAAA,CACN,IAAK,UACH,MAAO,UACT,IAAK,YACH,MAAO,UACT,IAAK,WACH,MAAO,SAAA,CAEb,CAEA,MAAMU,GACJ,+EAEF,SAASC,IAA8B,CACrC,GAAI,OAAO,UAAc,IACvB,MAAO,GAGT,MAAMC,EAAK,UAAU,WAAa,UAAU,QAAU,GAKtD,GAJIF,GAAgB,KAAKE,CAAE,GAIvB,mBAAoB,WAAa,UAAU,eAAiB,EAC9D,MAAO,GAGT,GACE,OAAO,OAAW,KAClB,OAAO,OAAO,YAAe,WAE7B,GAAI,CACF,GAAI,OAAO,WAAW,mBAAmB,EAAE,QACzC,MAAO,EAEX,MAAQ,CAER,CAGF,MAAO,EACT,CAEA,SAASC,GAAM,CACb,KAAAC,EACA,aAAAC,EACA,cAAAC,CACF,EAIG,CAGD,MAAMC,EAAI,KAAK,IAAI,EAAG,KAAK,IAAI,EAAGH,EAAK,QAAQ,CAAC,EAC1CI,EAAW,EACXC,EAAU,EAEVC,EAAa,QADJD,EAAUF,GAAKE,EAAUD,EACP,MAE3BG,EAASd,GAAeO,EAAK,OAAO,EACpCQ,EAAOb,GAAaK,EAAK,OAAO,EAGhCvC,EAAIuC,EAAK,KAAOR,EAEhBiB,EADW,GAEXC,EAAaV,EAAK,KAAOS,EAAS,EAElCE,EAAe,IACfC,EAAQ,KAAK,IAAI,EAAGX,EAAe,EAAE,EAErCY,GADab,EAAK,KAAOW,EAAeX,EAAK,IAAMY,EAAQZ,EAAK,KACzC,IAAOC,EAAeQ,EAC7CK,EAASd,EAAK,IAAM,IAAOE,EAAgBO,EAEjD,OACEM,MAAC,OAAI,MAAO,CAAE,OAAQT,EAAY,aAAcA,GAC9C,SAAAS,EAAAA,IAAC,MAAA,CACC,MAAOL,EACP,OAAQA,EACR,QAAS,GAAG,CAACnB,EAAU,CAAC,IAAI,CAACC,EAAU,CAAC,IAAID,CAAO,IAAIC,CAAO,GAC9D,MAAO,CACL,SAAU,WACV,KAAM,GAAGqB,CAAM,KACf,IAAK,GAAGC,CAAK,KACb,OAAQd,EAAK,OACb,QAAS,EACT,cAAe,OACf,SAAU,UACV,WAAY,mBAAA,EAEd,cAAY,OAEZ,SAAAe,EAAAA,IAAC,IAAA,CACC,UAAW,UAAUf,EAAK,WAAW,IACrC,MAAO,CAAE,OAAQM,EAAY,aAAcA,CAAA,EAE3C,SAAAS,EAAAA,IAAC,OAAA,CACC,EAAGzB,GACH,KAAAkB,EACA,YAAaR,EAAK,YAClB,OAAAO,EACA,cAAeP,EAAK,cACpB,YAAa,EACb,aAAa,qBACb,UAAW,aAAc,CAACT,EAAU,EAAK9B,CAAC,KAAM,CAAC+B,EAAU,EAAK/B,CAAC,WAAWA,CAAC,GAAA,CAAA,CAC/E,CAAA,CACF,CAAA,EAEJ,CAEJ,CAEA,SAAwBuD,GAAsB,CAC5C,MAAAhD,EAAQ,GACR,KAAAT,EACA,eAAAW,EAAiB,IACjB,kBAAAC,EAAoB,CAAE,IAAK,IAAK,IAAK,GAAA,EACrC,QAAAF,EAAU,CAAC,UAAW,UAAW,SAAS,EAC1C,QAAAG,EAAU,CAAE,OAAQ,CAAC,IAAM,GAAI,EAAG,KAAM,CAAC,IAAM,GAAI,CAAA,EACnD,UAAA6C,EAAY,EACd,EAA+B,CAI7B,MAAMC,EAAqB,IACrB,OAAO,OAAW,IACb,CAAE,MAAO,IAAmB,OAAQ,GAAA,EAEtC,CACL,MAAO,OAAO,WACd,OAAQ,KAAK,IAAI,IAAoB,OAAO,WAAW,CAAA,EAGrD,CAACC,EAAUC,CAAW,EAAIjF,EAAAA,SAAS+E,CAAkB,EACrD,CAACG,EAAgBC,CAAiB,EAAInF,EAAAA,SAAS,IACnD0D,GAAA,CAAmB,EAGrBlE,EAAAA,UAAU,IAAM,CACd,GAAI,OAAO,OAAW,IAAa,OACnC,IAAIhI,EAAuB,KAC3B,MAAM4N,EAAe,IAAM,CACrB5N,wBAA4BA,CAAK,EACrCA,EAAQ,sBAAsB,IAAM,CAClC,MAAM6N,EAAY,OAAO,WACnBC,EAAa,KAAK,IAAI,IAAoB,OAAO,WAAW,EAClEL,EAAahL,GAET,KAAK,IAAIA,EAAK,MAAQoL,CAAS,EAAI,IACnC,KAAK,IAAIpL,EAAK,OAASqL,CAAU,EAAI,GAE9BrL,EAEF,CAAE,MAAOoL,EAAW,OAAQC,CAAA,CACpC,CACH,CAAC,CACH,EACA,cAAO,iBAAiB,SAAUF,EAAc,CAAE,QAAS,GAAM,EACjE,OAAO,gBAAgB,iBAAiB,SAAUA,CAAY,EACvD,IAAM,CACP5N,wBAA4BA,CAAK,EACrC,OAAO,oBAAoB,SAAU4N,CAAY,EACjD,OAAO,gBAAgB,oBAAoB,SAAUA,CAAY,CACnE,CACF,EAAG,CAAA,CAAE,EAEL5F,EAAAA,UAAU,IAAM,CACd2F,EAAkBzB,IAAoB,CACxC,EAAG,CAAA,CAAE,EAEL,MAAMI,EAAe,KAAK,IAAI,IAAmBkB,EAAS,KAAK,EACzDjB,EAAgB,KAAK,IAAI,IAAoBiB,EAAS,MAAM,EAE5DO,EADWzB,GAAgB,IAE7B,KAAK,IAAI,GAAI,KAAK,MAAMjC,EAAQ,GAAI,CAAC,EACrCA,EACE2D,EAAkBN,EAElBO,EAASC,EAAAA,QACb,IACE9D,GAAe,CACb,MAAO2D,EACP,KAAMnE,GAAQ,IAAI,KAAA,EAAO,cAAc,MAAM,EAAG,EAAE,EAClD,QAAAU,EACA,eAAAC,EACA,kBAAAC,EACA,QAAAC,CAAA,CACD,EAAE,KAAK,CAAClL,EAAGC,IAAMD,EAAE,OAASC,EAAE,MAAM,EACvC,CAACuO,EAAgBnE,EAAMU,EAASC,EAAgBC,EAAmBC,CAAO,CAAA,EAGtE0D,EAAaD,EAAAA,QAAQ,IAAM,CAC/B,MAAME,EAAoB,CAAA,EACpBC,EAAmB,CAAA,EACnBC,EAAmB,CAAA,EACzB,UAAWC,KAASN,EACdM,EAAM,SAAW,EAAGH,EAAK,KAAKG,CAAK,EAC9BA,EAAM,SAAW,EAAGF,EAAI,KAAKE,CAAK,EACtCD,EAAI,KAAKC,CAAK,EAErB,MAAO,CAAE,KAAAH,EAAM,IAAAC,EAAK,IAAAC,CAAA,CACtB,EAAG,CAACL,CAAM,CAAC,EAELO,EAAe,GACfC,EAAc,IACdC,EAAc,IAGd,CAAE,QAAAC,CAAA,EAAYrH,GAAA,EACdsH,GAAiBpF,GAAUmF,EAAS,CACxC,UAAW,IACX,QAAS,GACT,KAAM,EAAA,CACP,EACKE,GAAe3G,EAAe,CAAC,EAC/B4G,EAAed,EACjBa,GACAnB,EACEkB,GACAD,EACAI,GAAQ7F,EAAa4F,EAAetN,GAAM,CAACA,EAAIgN,CAAY,EAC3DQ,GAAO9F,EAAa4F,EAAetN,GAAM,CAACA,EAAIiN,CAAW,EACzDQ,GAAO/F,EAAa4F,EAAetN,GAAM,CAACA,EAAIkN,CAAW,EAE/D,OACEtB,EAAAA,IAAC,MAAA,CACC,UAAW,qCAAqCE,CAAS,GACzD,cAAY,OAEX,SAAA,CACC,CAAE,IAAK,OAAQ,GAAIyB,GAAO,MAAOZ,EAAW,IAAA,EAC5C,CAAE,IAAK,MAAO,GAAIa,GAAM,MAAOb,EAAW,GAAA,EAC1C,CAAE,IAAK,MAAO,GAAIc,GAAM,MAAOd,EAAW,GAAA,CAAI,EAC9C,IAAI,CAAC,CAAE,IAAAe,EAAK,GAAAC,EAAI,MAAAC,CAAA,IAChBA,EAAM,OACJhC,EAAAA,IAACiC,GAAO,IAAP,CAEC,MAAO,CACL,EAAGrB,EAAkB,EAAImB,EACzB,SAAU,WACV,MAAO,EACP,cAAe,MAAA,EAEjB,cAAY,OAEX,SAAAC,EAAM,IAAKb,GACVnB,EAAAA,IAAChB,GAAA,CAEC,KAAMmC,EACN,aAAAjC,EACA,cAAAC,CAAA,EAHKgC,EAAM,EAAA,CAKd,CAAA,EAhBIW,CAAA,EAkBL,IAAA,CACN,CAAA,CAGN","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]}